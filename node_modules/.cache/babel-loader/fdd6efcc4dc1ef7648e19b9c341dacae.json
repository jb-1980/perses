{"ast":null,"code":"import _toConsumableArray from \"/home/joseph/projects/perses/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _toArray from \"/home/joseph/projects/perses/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _objectSpread from \"/home/joseph/projects/perses/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nvar _jsxFileName = \"/home/joseph/projects/perses/src/perses-markdown.js\";\n// Modified version of https://github.com/Khan/perseus/blob/master/src/perseus-markdown.jsx\nimport React from \"react\";\nimport SimpleMarkdown from \"simple-markdown\";\nimport { TeX } from \"./UI\";\nimport { Util } from \"./util.js\";\n/**\n * This match function matches math in `$`s, such as:\n *\n * $y = x + 1$\n *\n * It functions roughly like the following regex:\n * /\\$([^\\$]*)\\$/\n *\n * Unfortunately, math may have other `$`s inside it, as\n * long as they are inside `{` braces `}`, mostly for\n * `\\text{ $math$ }`.\n *\n * To parse this, we can't use a regex, since we\n * should support arbitrary nesting (even though\n * MathJax actually only supports two levels of nesting\n * here, which we *could* parse with a regex).\n *\n * Non-regex matchers like this are now a first-class\n * concept in simple-markdown. Yay!\n *\n * This can also match block-math, which is math alone in a paragraph.\n */\n\nvar mathMatcher = function mathMatcher(source, state, isBlock) {\n  var length = source.length;\n  var index = 0; // When looking for blocks, skip over leading spaces\n\n  if (isBlock) {\n    if (state.inline) {\n      return null;\n    }\n\n    while (index < length && source[index] === \" \") {\n      index++;\n    }\n  } // Our source must start with a \"$\"\n\n\n  if (!(index < length && source[index] === \"$\")) {\n    return null;\n  }\n\n  index++;\n  var startIndex = index;\n  var braceLevel = 0; // Loop through the source, looking for a closing '$'\n  // closing '$'s only count if they are not escaped with\n  // a `\\`, and we are not in nested `{}` braces.\n\n  while (index < length) {\n    var character = source[index];\n\n    if (character === \"\\\\\") {\n      // Consume both the `\\` and the escaped char as a single\n      // token.\n      // This is so that the second `$` in `$\\\\$` closes\n      // the math expression, since the first `\\` is escaping\n      // the second `\\`, but the second `\\` is not escaping\n      // the second `$`.\n      // This also handles the case of escaping `$`s or\n      // braces `\\{`\n      index++;\n    } else if (braceLevel <= 0 && character === \"$\") {\n      var endIndex = index + 1;\n\n      if (isBlock) {\n        // Look for two trailing newlines after the closing `$`\n        var match = /^(?: *\\n){2,}/.exec(source.slice(endIndex));\n        endIndex = match ? endIndex + match[0].length : null;\n      } // Return an array that looks like the results of a\n      // regex's .exec function:\n      // capture[0] is the whole string\n      // capture[1] is the first \"paren\" match, which is the\n      //   content of the math here, as if we wrote the regex\n      //   /\\$([^\\$]*)\\$/\n\n\n      if (endIndex) {\n        return [source.substring(0, endIndex), source.substring(startIndex, index)];\n      }\n\n      return null;\n    } else if (character === \"{\") {\n      braceLevel++;\n    } else if (character === \"}\") {\n      braceLevel--;\n    } else if (character === \"\\n\" && source[index - 1] === \"\\n\") {\n      // This is a weird case we supported in the old\n      // math implementation--double newlines break\n      // math. I'm preserving it for now because content\n      // creators might have questions with single '$'s\n      // in paragraphs...\n      return null;\n    }\n\n    index++;\n  } // we didn't find a closing `$`\n\n\n  return null;\n};\n\nvar mathMatch = function mathMatch(source, state) {\n  return mathMatcher(source, state, false);\n};\n\nvar blockMathMatch = function blockMathMatch(source, state) {\n  return mathMatcher(source, state, true);\n};\n\nvar TITLED_TABLE_REGEX = new RegExp(\"^\\\\|\\\\| +(.*) +\\\\|\\\\| *\\\\n\" + \"(\" + // The simple-markdown nptable regex, without\n// the leading `^`\nSimpleMarkdown.defaultRules.nptable.match.regex.source.substring(1) + \")\");\nvar crowdinJiptMatcher = SimpleMarkdown.blockRegex(/^(crwdns.*)\\n\\s*\\n/);\n\nvar rules = _objectSpread({}, SimpleMarkdown.defaultRules, {\n  // NOTE: basically ignored by JIPT. wraps everything at the outer layer\n  columns: {\n    order: -2,\n    match: SimpleMarkdown.blockRegex(/^([\\s\\S]*\\n\\n)={5,}\\n\\n([\\s\\S]*)/),\n    parse: function parse(capture, _parse, state) {\n      return {\n        col1: _parse(capture[1], state),\n        col2: _parse(capture[2], state)\n      };\n    },\n    react: function react(node, output, state) {\n      return React.createElement(\"div\", {\n        className: \"perseus-two-columns\",\n        key: state.key,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 136\n        },\n        __self: this\n      }, React.createElement(\"div\", {\n        className: \"perseus-column\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 137\n        },\n        __self: this\n      }, React.createElement(\"div\", {\n        className: \"perseus-column-content\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 138\n        },\n        __self: this\n      }, output(node.col1, state))), React.createElement(\"div\", {\n        className: \"perseus-column\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 142\n        },\n        __self: this\n      }, React.createElement(\"div\", {\n        className: \"perseus-column-content\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 143\n        },\n        __self: this\n      }, output(node.col2, state))));\n    }\n  },\n  // Match paragraphs consisting solely of crowdin IDs\n  // (they look roughly like crwdns9238932:0), which means that\n  // crowdin is going to take the DOM node that ID is rendered into\n  // and count it as the top-level translation node. They mutate this\n  // node, so we need to make sure it is an outer node, not an inner\n  // span. So here we parse this separately and just output the\n  // raw string, which becomes the body of the <QuestionParagraph>\n  // created by the Renderer.\n  // This currently (2015-09-01) affects only articles, since\n  // for exercises the renderer just renders the crowdin id to the\n  // renderer div.\n  crowdinId: {\n    order: -1,\n    match: function match(source, state, prevCapture) {\n      // Only match on the just-in-place translation site\n      if (state.isJipt) {\n        return crowdinJiptMatcher(source, state, prevCapture);\n      } else {\n        return null;\n      }\n    },\n    parse: function parse(capture, _parse2, state) {\n      return {\n        id: capture[1]\n      };\n    },\n    react: function react(node, output, state) {\n      return node.id;\n    }\n  },\n  // This is pretty much horrible, but we have a regex here to capture an\n  // entire table + a title. capture[1] is the title. capture[2] of the\n  // regex is a copy of the simple-markdown nptable regex. Then we turn\n  // our capture[2] into tableCapture[0], and any further captures in\n  // our table regex into tableCapture[1..], and we pass tableCapture to\n  // our nptable regex\n  titledTable: {\n    // process immediately before nptables\n    order: SimpleMarkdown.defaultRules.nptable.order - 0.5,\n    match: SimpleMarkdown.blockRegex(TITLED_TABLE_REGEX),\n    parse: function parse(capture, _parse3, state) {\n      var title = SimpleMarkdown.parseInline(_parse3, capture[1], state); // Remove our [0] and [1] captures, and pass the rest to\n      // the nptable parser\n\n      var _capture = _toArray(capture),\n          capture1 = _capture[0],\n          capture2 = _capture[1],\n          tableCapture = _capture.slice(2);\n\n      var table = SimpleMarkdown.defaultRules.nptable.parse(tableCapture, _parse3, state);\n      return {\n        title: title,\n        table: table\n      };\n    },\n    react: function react(node, output, state) {\n      var contents;\n\n      if (!node.table) {\n        contents = \"//invalid table//\";\n      } else {\n        var tableOutput = SimpleMarkdown.defaultRules.table.react(node.table, output, state);\n        var caption = React.createElement(\"caption\", {\n          key: \"caption\",\n          className: \"perseus-table-title\",\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 213\n          },\n          __self: this\n        }, output(node.title, state)); // Splice the caption into the table's children with the\n        // caption as the first child.\n\n        contents = React.cloneElement(tableOutput, null, [caption].concat(_toConsumableArray(tableOutput.props.children)));\n      } // Note: if the DOM structure changes, edit the Zoomable wrapper\n      // in src/renderer.jsx.\n\n\n      return React.createElement(\"div\", {\n        className: \"perseus-titled-table\",\n        key: state.key,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 229\n        },\n        __self: this\n      }, contents);\n    }\n  },\n  widget: {\n    order: SimpleMarkdown.defaultRules.link.order - 0.75,\n    match: SimpleMarkdown.inlineRegex(Util.rWidgetRule),\n    parse: function parse(capture, _parse4, state) {\n      return {\n        id: capture[1],\n        widgetType: capture[2]\n      };\n    },\n    react: function react(node, output, state) {\n      // The actual output is handled in the renderer, where\n      // we know the current widget props/state. This is\n      // just a stub for testing.\n      console.log({\n        node: node\n      });\n      return React.createElement(\"em\", {\n        key: state.key,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 249\n        },\n        __self: this\n      }, \"[Widget: \", node.id, \"]\");\n    }\n  },\n  blockMath: {\n    order: SimpleMarkdown.defaultRules.codeBlock.order + 0.5,\n    match: blockMathMatch,\n    parse: function parse(capture, _parse5, state) {\n      return {\n        content: capture[1]\n      };\n    },\n    react: function react(node, output, state) {\n      // The actual output is handled in the renderer, because\n      // it needs to pass in an `onRender` callback prop. This\n      // is just a stub for testing.\n      return React.createElement(TeX, {\n        key: state.key,\n        texString: node.content,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 264\n        },\n        __self: this\n      });\n    }\n  },\n  math: {\n    order: SimpleMarkdown.defaultRules.link.order - 0.25,\n    match: mathMatch,\n    parse: function parse(capture, _parse6, state) {\n      return {\n        content: capture[1]\n      };\n    },\n    react: function react(node, output, state) {\n      // The actual output is handled in the renderer, because\n      // it needs to pass in an `onRender` callback prop. This\n      // is just a stub for testing.\n      return React.createElement(TeX, {\n        key: state.key,\n        texString: node.content,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 279\n        },\n        __self: this\n      });\n    }\n  },\n  unescapedDollar: {\n    order: SimpleMarkdown.defaultRules.link.order - 0.24,\n    match: SimpleMarkdown.inlineRegex(/^(?!\\\\)\\$/),\n    parse: function parse(capture, _parse7, state) {\n      return {};\n    },\n    react: function react(node, output, state) {\n      // Unescaped dollar signs render correctly, but result in\n      // untranslatable text after the i18n python linter flags it\n      return \"$\";\n    }\n  },\n  fence: _objectSpread({}, SimpleMarkdown.defaultRules.fence, {\n    parse: function parse(capture, _parse8, state) {\n      var node = SimpleMarkdown.defaultRules.fence.parse(capture, _parse8, state); // support screenreader-only text with ```alt\n\n      if (node.lang === \"alt\") {\n        return {\n          type: \"codeBlock\",\n          lang: \"alt\",\n          // default codeBlock parsing doesn't parse the contents.\n          // We need to parse the contents for things like table\n          // support :).\n          // The \\n\\n is because the inside of the codeblock might\n          // not end in double newlines for block rules, because\n          // ordinarily we don't parse this :).\n          content: _parse8(node.content + \"\\n\\n\", state)\n        };\n      } else {\n        return node;\n      }\n    }\n  }),\n  // Extend the SimpleMarkdown link parser to make the link\n  // zero-rating-friendly if necessary. No changes will be made for\n  // non-zero-rated requests, but zero-rated requests will be re-pointed at\n  // either the zero-rated version of khanacademy.org or the external link\n  // warning interstitial. We also replace the default <a /> tag with a custom\n  // element, if necessary.\n  link: _objectSpread({}, SimpleMarkdown.defaultRules.link, {\n    react: function react(node, output, state) {\n      var link = SimpleMarkdown.defaultRules.link.react(node, output, state);\n      var href = link.props.href;\n\n      var newProps = _objectSpread({}, link.props, {\n        href: href\n      });\n\n      if (state.baseElements && state.baseElements.Link) {\n        return state.baseElements.Link(newProps);\n      } else {\n        return React.cloneElement(link, newProps);\n      }\n    }\n  }),\n  codeBlock: _objectSpread({}, SimpleMarkdown.defaultRules.codeBlock, {\n    react: function react(node, output, state) {\n      // ideally this should be a different rule, with only an\n      // output function, but right now that breaks the parser.\n      if (node.lang === \"alt\") {\n        return React.createElement(\"div\", {\n          key: state.key,\n          className: \"perseus-markdown-alt perseus-sr-only\",\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 346\n          },\n          __self: this\n        }, output(node.content, state));\n      } else {\n        return SimpleMarkdown.defaultRules.codeBlock.react(node, output, state);\n      }\n    }\n  }),\n  list: _objectSpread({}, SimpleMarkdown.defaultRules.list, {\n    match: function match(source, state, prevCapture) {\n      // Since lists can contain double newlines and we have special\n      // handling of double newlines while parsing jipt content, just\n      // disable the list parser.\n      if (state.isJipt) {\n        return null;\n      } else {\n        return SimpleMarkdown.defaultRules.list.match(source, state, prevCapture);\n      }\n    }\n  })\n}); // Return true if the specified parse tree node represents inline content\n// and false otherwise. We need this so that lint nodes can figure out whether\n// they should behave as an inline wrapper or a block wrapper\n\n\nfunction isInline(node) {\n  return !!(node && node.type && inlineNodeTypes.hasOwnProperty(node.type));\n}\n\nvar inlineNodeTypes = {\n  text: true,\n  math: true,\n  unescapedDollar: true,\n  link: true,\n  img: true,\n  strong: true,\n  u: true,\n  em: true,\n  del: true,\n  code: true\n};\nvar builtParser = SimpleMarkdown.parserFor(rules);\n\nvar parse = function parse(source, state) {\n  var paragraphedSource = source + \"\\n\\n\";\n  return builtParser(paragraphedSource, _objectSpread({\n    inline: false\n  }, state));\n};\n\nvar inlineParser = function inlineParser(source, state) {\n  return builtParser(source, _objectSpread({\n    inline: false\n  }, state));\n};\n/**\n * Traverse all of the nodes in the Perseus Markdown AST. The callback is\n * called for each node in the AST.\n */\n\n\nvar traverseContent = function traverseContent(ast, cb) {\n  if (Array.isArray(ast)) {\n    ast.forEach(function (node) {\n      return traverseContent(node, cb);\n    });\n  } else if (Util.isObject(ast)) {\n    cb(ast);\n\n    if (ast.type === \"table\") {\n      traverseContent(ast.header, cb);\n      traverseContent(ast.cells, cb);\n    } else if (ast.type === \"list\") {\n      traverseContent(ast.items, cb);\n    } else if (ast.type === \"titledTable\") {\n      traverseContent(ast.table, cb);\n    } else if (ast.type === \"columns\") {\n      traverseContent(ast.col1, cb);\n      traverseContent(ast.col2, cb);\n    } else if (Array.isArray(ast.content)) {\n      traverseContent(ast.content, cb);\n    }\n  }\n};\n/**\n * Pull out text content from a Perseus Markdown AST.\n * Returns an array of strings.\n */\n\n\nvar getContent = function getContent(ast) {\n  // Simplify logic by dealing with a single AST node at a time\n  if (Array.isArray(ast)) {\n    var _ref;\n\n    var arr = ast.map(getContent);\n    return (_ref = []).concat.apply(_ref, _toConsumableArray(arr));\n  } // Base case: This is where we actually extract text content\n\n\n  if (ast.content && Util.isString(ast.content)) {\n    // Collapse whitespace within content unless it is code\n    if (ast.type.toLowerCase().indexOf(\"code\") !== -1) {\n      // In case this is the sole child of a paragraph,\n      // prevent whitespace from being trimmed later\n      return [\"\", ast.content, \"\"];\n    } else {\n      return [ast.content.replace(/\\s+/g, \" \")];\n    }\n  } // Recurse through child AST nodes\n  // Assumptions made:\n  // 1) Child AST nodes are either direct properties or inside\n  //    arbitrarily nested lists that are direct properties.\n  // 2) Only AST nodes have a 'type' property.\n\n\n  var children = Object.values(ast).reduce(function (a, b) {\n    return a.concat(b);\n  }, []).filter(function (object) {\n    return object != null && object.hasOwnProperty(\"type\");\n  });\n\n  if (!children.length) {\n    return [];\n  } else {\n    var nestedContent = getContent(children);\n\n    if (ast.type === \"paragraph\" && nestedContent.length) {\n      // Trim whitespace before or after a paragraph\n      nestedContent[0] = nestedContent[0].replace(/^\\s+/, \"\");\n      var last = nestedContent.length - 1;\n      nestedContent[last] = nestedContent[last].replace(/\\s+$/, \"\");\n    }\n\n    return nestedContent;\n  }\n};\n/**\n * Count the number of characters in Perseus Markdown source.\n * Markdown markup and widget references are ignored.\n */\n\n\nvar characterCount = function characterCount(source) {\n  var ast = parse(source);\n  var content = getContent(ast).join(\"\");\n  return content.length;\n};\n\nexport default {\n  characterCount: characterCount,\n  traverseContent: traverseContent,\n  parse: parse,\n  parseInline: inlineParser,\n  reactFor: SimpleMarkdown.reactFor,\n  ruleOutput: SimpleMarkdown.ruleOutput(rules, \"react\"),\n  basicOutput: SimpleMarkdown.reactFor(SimpleMarkdown.ruleOutput(rules, \"react\")),\n  sanitizeUrl: SimpleMarkdown.sanitizeUrl\n};","map":{"version":3,"sources":["/home/joseph/projects/perses/src/perses-markdown.js"],"names":["React","SimpleMarkdown","TeX","Util","mathMatcher","source","state","isBlock","length","index","inline","startIndex","braceLevel","character","endIndex","match","exec","slice","substring","mathMatch","blockMathMatch","TITLED_TABLE_REGEX","RegExp","defaultRules","nptable","regex","crowdinJiptMatcher","blockRegex","rules","columns","order","parse","capture","col1","col2","react","node","output","key","crowdinId","prevCapture","isJipt","id","titledTable","title","parseInline","capture1","capture2","tableCapture","table","contents","tableOutput","caption","cloneElement","props","children","widget","link","inlineRegex","rWidgetRule","widgetType","console","log","blockMath","codeBlock","content","math","unescapedDollar","fence","lang","type","href","newProps","baseElements","Link","list","isInline","inlineNodeTypes","hasOwnProperty","text","img","strong","u","em","del","code","builtParser","parserFor","paragraphedSource","inlineParser","traverseContent","ast","cb","Array","isArray","forEach","isObject","header","cells","items","getContent","arr","map","concat","isString","toLowerCase","indexOf","replace","Object","values","reduce","a","b","filter","object","nestedContent","last","characterCount","join","reactFor","ruleOutput","basicOutput","sanitizeUrl"],"mappings":"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","sourcesContent":["// Modified version of https://github.com/Khan/perseus/blob/master/src/perseus-markdown.jsx\nimport React from \"react\"\nimport SimpleMarkdown from \"simple-markdown\"\nimport { TeX } from \"./UI\"\nimport { Util } from \"./util.js\"\n\n/**\n * This match function matches math in `$`s, such as:\n *\n * $y = x + 1$\n *\n * It functions roughly like the following regex:\n * /\\$([^\\$]*)\\$/\n *\n * Unfortunately, math may have other `$`s inside it, as\n * long as they are inside `{` braces `}`, mostly for\n * `\\text{ $math$ }`.\n *\n * To parse this, we can't use a regex, since we\n * should support arbitrary nesting (even though\n * MathJax actually only supports two levels of nesting\n * here, which we *could* parse with a regex).\n *\n * Non-regex matchers like this are now a first-class\n * concept in simple-markdown. Yay!\n *\n * This can also match block-math, which is math alone in a paragraph.\n */\nvar mathMatcher = (source, state, isBlock) => {\n  var length = source.length\n  var index = 0\n\n  // When looking for blocks, skip over leading spaces\n  if (isBlock) {\n    if (state.inline) {\n      return null\n    }\n    while (index < length && source[index] === \" \") {\n      index++\n    }\n  }\n\n  // Our source must start with a \"$\"\n  if (!(index < length && source[index] === \"$\")) {\n    return null\n  }\n\n  index++\n  var startIndex = index\n  var braceLevel = 0\n\n  // Loop through the source, looking for a closing '$'\n  // closing '$'s only count if they are not escaped with\n  // a `\\`, and we are not in nested `{}` braces.\n  while (index < length) {\n    var character = source[index]\n\n    if (character === \"\\\\\") {\n      // Consume both the `\\` and the escaped char as a single\n      // token.\n      // This is so that the second `$` in `$\\\\$` closes\n      // the math expression, since the first `\\` is escaping\n      // the second `\\`, but the second `\\` is not escaping\n      // the second `$`.\n      // This also handles the case of escaping `$`s or\n      // braces `\\{`\n      index++\n    } else if (braceLevel <= 0 && character === \"$\") {\n      var endIndex = index + 1\n      if (isBlock) {\n        // Look for two trailing newlines after the closing `$`\n        var match = /^(?: *\\n){2,}/.exec(source.slice(endIndex))\n        endIndex = match ? endIndex + match[0].length : null\n      }\n\n      // Return an array that looks like the results of a\n      // regex's .exec function:\n      // capture[0] is the whole string\n      // capture[1] is the first \"paren\" match, which is the\n      //   content of the math here, as if we wrote the regex\n      //   /\\$([^\\$]*)\\$/\n      if (endIndex) {\n        return [\n          source.substring(0, endIndex),\n          source.substring(startIndex, index),\n        ]\n      }\n      return null\n    } else if (character === \"{\") {\n      braceLevel++\n    } else if (character === \"}\") {\n      braceLevel--\n    } else if (character === \"\\n\" && source[index - 1] === \"\\n\") {\n      // This is a weird case we supported in the old\n      // math implementation--double newlines break\n      // math. I'm preserving it for now because content\n      // creators might have questions with single '$'s\n      // in paragraphs...\n      return null\n    }\n\n    index++\n  }\n\n  // we didn't find a closing `$`\n  return null\n}\nvar mathMatch = (source, state) => mathMatcher(source, state, false)\nvar blockMathMatch = (source, state) => mathMatcher(source, state, true)\n\nvar TITLED_TABLE_REGEX = new RegExp(\n  \"^\\\\|\\\\| +(.*) +\\\\|\\\\| *\\\\n\" +\n    \"(\" +\n    // The simple-markdown nptable regex, without\n    // the leading `^`\n    SimpleMarkdown.defaultRules.nptable.match.regex.source.substring(1) +\n    \")\"\n)\n\nvar crowdinJiptMatcher = SimpleMarkdown.blockRegex(/^(crwdns.*)\\n\\s*\\n/)\n\nvar rules = {\n  ...SimpleMarkdown.defaultRules,\n  // NOTE: basically ignored by JIPT. wraps everything at the outer layer\n  columns: {\n    order: -2,\n    match: SimpleMarkdown.blockRegex(/^([\\s\\S]*\\n\\n)={5,}\\n\\n([\\s\\S]*)/),\n    parse: (capture, parse, state) => {\n      return {\n        col1: parse(capture[1], state),\n        col2: parse(capture[2], state),\n      }\n    },\n    react: (node, output, state) => {\n      return (\n        <div className=\"perseus-two-columns\" key={state.key}>\n          <div className=\"perseus-column\">\n            <div className=\"perseus-column-content\">\n              {output(node.col1, state)}\n            </div>\n          </div>\n          <div className=\"perseus-column\">\n            <div className=\"perseus-column-content\">\n              {output(node.col2, state)}\n            </div>\n          </div>\n        </div>\n      )\n    },\n  },\n  // Match paragraphs consisting solely of crowdin IDs\n  // (they look roughly like crwdns9238932:0), which means that\n  // crowdin is going to take the DOM node that ID is rendered into\n  // and count it as the top-level translation node. They mutate this\n  // node, so we need to make sure it is an outer node, not an inner\n  // span. So here we parse this separately and just output the\n  // raw string, which becomes the body of the <QuestionParagraph>\n  // created by the Renderer.\n  // This currently (2015-09-01) affects only articles, since\n  // for exercises the renderer just renders the crowdin id to the\n  // renderer div.\n  crowdinId: {\n    order: -1,\n    match: (source, state, prevCapture) => {\n      // Only match on the just-in-place translation site\n      if (state.isJipt) {\n        return crowdinJiptMatcher(source, state, prevCapture)\n      } else {\n        return null\n      }\n    },\n    parse: (capture, parse, state) => ({ id: capture[1] }),\n    react: (node, output, state) => node.id,\n  },\n  // This is pretty much horrible, but we have a regex here to capture an\n  // entire table + a title. capture[1] is the title. capture[2] of the\n  // regex is a copy of the simple-markdown nptable regex. Then we turn\n  // our capture[2] into tableCapture[0], and any further captures in\n  // our table regex into tableCapture[1..], and we pass tableCapture to\n  // our nptable regex\n  titledTable: {\n    // process immediately before nptables\n    order: SimpleMarkdown.defaultRules.nptable.order - 0.5,\n    match: SimpleMarkdown.blockRegex(TITLED_TABLE_REGEX),\n    parse: (capture, parse, state) => {\n      var title = SimpleMarkdown.parseInline(parse, capture[1], state)\n\n      // Remove our [0] and [1] captures, and pass the rest to\n      // the nptable parser\n      var [capture1, capture2, ...tableCapture] = capture\n      var table = SimpleMarkdown.defaultRules.nptable.parse(\n        tableCapture,\n        parse,\n        state\n      )\n      return {\n        title: title,\n        table: table,\n      }\n    },\n    react: (node, output, state) => {\n      let contents\n      if (!node.table) {\n        contents = \"//invalid table//\"\n      } else {\n        const tableOutput = SimpleMarkdown.defaultRules.table.react(\n          node.table,\n          output,\n          state\n        )\n\n        const caption = (\n          <caption key=\"caption\" className=\"perseus-table-title\">\n            {output(node.title, state)}\n          </caption>\n        )\n\n        // Splice the caption into the table's children with the\n        // caption as the first child.\n        contents = React.cloneElement(tableOutput, null, [\n          caption,\n          ...tableOutput.props.children,\n        ])\n      }\n\n      // Note: if the DOM structure changes, edit the Zoomable wrapper\n      // in src/renderer.jsx.\n      return (\n        <div className=\"perseus-titled-table\" key={state.key}>\n          {contents}\n        </div>\n      )\n    },\n  },\n  widget: {\n    order: SimpleMarkdown.defaultRules.link.order - 0.75,\n    match: SimpleMarkdown.inlineRegex(Util.rWidgetRule),\n    parse: (capture, parse, state) => {\n      return {\n        id: capture[1],\n        widgetType: capture[2],\n      }\n    },\n    react: (node, output, state) => {\n      // The actual output is handled in the renderer, where\n      // we know the current widget props/state. This is\n      // just a stub for testing.\n      console.log({ node })\n      return <em key={state.key}>[Widget: {node.id}]</em>\n    },\n  },\n  blockMath: {\n    order: SimpleMarkdown.defaultRules.codeBlock.order + 0.5,\n    match: blockMathMatch,\n    parse: (capture, parse, state) => {\n      return {\n        content: capture[1],\n      }\n    },\n    react: (node, output, state) => {\n      // The actual output is handled in the renderer, because\n      // it needs to pass in an `onRender` callback prop. This\n      // is just a stub for testing.\n      return <TeX key={state.key} texString={node.content} />\n    },\n  },\n  math: {\n    order: SimpleMarkdown.defaultRules.link.order - 0.25,\n    match: mathMatch,\n    parse: (capture, parse, state) => {\n      return {\n        content: capture[1],\n      }\n    },\n    react: (node, output, state) => {\n      // The actual output is handled in the renderer, because\n      // it needs to pass in an `onRender` callback prop. This\n      // is just a stub for testing.\n      return <TeX key={state.key} texString={node.content} />\n    },\n  },\n  unescapedDollar: {\n    order: SimpleMarkdown.defaultRules.link.order - 0.24,\n    match: SimpleMarkdown.inlineRegex(/^(?!\\\\)\\$/),\n    parse: (capture, parse, state) => {\n      return {}\n    },\n    react: (node, output, state) => {\n      // Unescaped dollar signs render correctly, but result in\n      // untranslatable text after the i18n python linter flags it\n      return \"$\"\n    },\n  },\n  fence: {\n    ...SimpleMarkdown.defaultRules.fence,\n    parse: (capture, parse, state) => {\n      var node = SimpleMarkdown.defaultRules.fence.parse(capture, parse, state)\n\n      // support screenreader-only text with ```alt\n      if (node.lang === \"alt\") {\n        return {\n          type: \"codeBlock\",\n          lang: \"alt\",\n          // default codeBlock parsing doesn't parse the contents.\n          // We need to parse the contents for things like table\n          // support :).\n          // The \\n\\n is because the inside of the codeblock might\n          // not end in double newlines for block rules, because\n          // ordinarily we don't parse this :).\n          content: parse(node.content + \"\\n\\n\", state),\n        }\n      } else {\n        return node\n      }\n    },\n  },\n  // Extend the SimpleMarkdown link parser to make the link\n  // zero-rating-friendly if necessary. No changes will be made for\n  // non-zero-rated requests, but zero-rated requests will be re-pointed at\n  // either the zero-rated version of khanacademy.org or the external link\n  // warning interstitial. We also replace the default <a /> tag with a custom\n  // element, if necessary.\n  link: {\n    ...SimpleMarkdown.defaultRules.link,\n    react: function(node, output, state) {\n      const link = SimpleMarkdown.defaultRules.link.react(node, output, state)\n\n      let href = link.props.href\n\n      const newProps = { ...link.props, href }\n\n      if (state.baseElements && state.baseElements.Link) {\n        return state.baseElements.Link(newProps)\n      } else {\n        return React.cloneElement(link, newProps)\n      }\n    },\n  },\n  codeBlock: {\n    ...SimpleMarkdown.defaultRules.codeBlock,\n    react: (node, output, state) => {\n      // ideally this should be a different rule, with only an\n      // output function, but right now that breaks the parser.\n      if (node.lang === \"alt\") {\n        return (\n          <div key={state.key} className=\"perseus-markdown-alt perseus-sr-only\">\n            {output(node.content, state)}\n          </div>\n        )\n      } else {\n        return SimpleMarkdown.defaultRules.codeBlock.react(node, output, state)\n      }\n    },\n  },\n  list: {\n    ...SimpleMarkdown.defaultRules.list,\n    match: (source, state, prevCapture) => {\n      // Since lists can contain double newlines and we have special\n      // handling of double newlines while parsing jipt content, just\n      // disable the list parser.\n      if (state.isJipt) {\n        return null\n      } else {\n        return SimpleMarkdown.defaultRules.list.match(\n          source,\n          state,\n          prevCapture\n        )\n      }\n    },\n  },\n}\n\n// Return true if the specified parse tree node represents inline content\n// and false otherwise. We need this so that lint nodes can figure out whether\n// they should behave as an inline wrapper or a block wrapper\nfunction isInline(node) {\n  return !!(node && node.type && inlineNodeTypes.hasOwnProperty(node.type))\n}\nconst inlineNodeTypes = {\n  text: true,\n  math: true,\n  unescapedDollar: true,\n  link: true,\n  img: true,\n  strong: true,\n  u: true,\n  em: true,\n  del: true,\n  code: true,\n}\n\nvar builtParser = SimpleMarkdown.parserFor(rules)\nvar parse = (source, state) => {\n  var paragraphedSource = source + \"\\n\\n\"\n\n  return builtParser(paragraphedSource, { inline: false, ...state })\n}\nvar inlineParser = (source, state) => {\n  return builtParser(source, { inline: false, ...state })\n}\n\n/**\n * Traverse all of the nodes in the Perseus Markdown AST. The callback is\n * called for each node in the AST.\n */\nvar traverseContent = (ast, cb) => {\n  if (Array.isArray(ast)) {\n    ast.forEach(node => traverseContent(node, cb))\n  } else if (Util.isObject(ast)) {\n    cb(ast)\n    if (ast.type === \"table\") {\n      traverseContent(ast.header, cb)\n      traverseContent(ast.cells, cb)\n    } else if (ast.type === \"list\") {\n      traverseContent(ast.items, cb)\n    } else if (ast.type === \"titledTable\") {\n      traverseContent(ast.table, cb)\n    } else if (ast.type === \"columns\") {\n      traverseContent(ast.col1, cb)\n      traverseContent(ast.col2, cb)\n    } else if (Array.isArray(ast.content)) {\n      traverseContent(ast.content, cb)\n    }\n  }\n}\n\n/**\n * Pull out text content from a Perseus Markdown AST.\n * Returns an array of strings.\n */\nvar getContent = ast => {\n  // Simplify logic by dealing with a single AST node at a time\n  if (Array.isArray(ast)) {\n    const arr = ast.map(getContent)\n    return [].concat(...arr)\n  }\n\n  // Base case: This is where we actually extract text content\n  if (ast.content && Util.isString(ast.content)) {\n    // Collapse whitespace within content unless it is code\n    if (ast.type.toLowerCase().indexOf(\"code\") !== -1) {\n      // In case this is the sole child of a paragraph,\n      // prevent whitespace from being trimmed later\n      return [\"\", ast.content, \"\"]\n    } else {\n      return [ast.content.replace(/\\s+/g, \" \")]\n    }\n  }\n\n  // Recurse through child AST nodes\n  // Assumptions made:\n  // 1) Child AST nodes are either direct properties or inside\n  //    arbitrarily nested lists that are direct properties.\n  // 2) Only AST nodes have a 'type' property.\n  var children = Object.values(ast)\n    .reduce((a, b) => a.concat(b), [])\n    .filter(object => object != null && object.hasOwnProperty(\"type\"))\n\n  if (!children.length) {\n    return []\n  } else {\n    var nestedContent = getContent(children)\n    if (ast.type === \"paragraph\" && nestedContent.length) {\n      // Trim whitespace before or after a paragraph\n      nestedContent[0] = nestedContent[0].replace(/^\\s+/, \"\")\n      var last = nestedContent.length - 1\n      nestedContent[last] = nestedContent[last].replace(/\\s+$/, \"\")\n    }\n    return nestedContent\n  }\n}\n\n/**\n * Count the number of characters in Perseus Markdown source.\n * Markdown markup and widget references are ignored.\n */\nvar characterCount = source => {\n  var ast = parse(source)\n  var content = getContent(ast).join(\"\")\n  return content.length\n}\n\nexport default {\n  characterCount,\n  traverseContent,\n  parse,\n  parseInline: inlineParser,\n  reactFor: SimpleMarkdown.reactFor,\n  ruleOutput: SimpleMarkdown.ruleOutput(rules, \"react\"),\n  basicOutput: SimpleMarkdown.reactFor(\n    SimpleMarkdown.ruleOutput(rules, \"react\")\n  ),\n  sanitizeUrl: SimpleMarkdown.sanitizeUrl,\n}\n"]},"metadata":{},"sourceType":"module"}