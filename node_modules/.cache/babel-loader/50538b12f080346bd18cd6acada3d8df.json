{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.SimpleMarkdown = factory());\n})(this, function () {\n  'use strict';\n  /* @flow */\n\n  /* @ts-check */\n\n  /**\n   * Simple-Markdown\n   * ===============\n   *\n   * Simple-Markdown's primary goal is to be easy to adapt. It aims\n   * to be compliant with John Gruber's [Markdown Syntax page][1],\n   * but compatiblity with other markdown implementations' edge-cases\n   * will be sacrificed where it conflicts with simplicity or\n   * extensibility.\n   *\n   * If your goal is to simply embed a standard markdown implementation\n   * in your website, simple-markdown is probably not the best library\n   * for you (although it should work). But if you have struggled to\n   * customize an existing library to meet your needs, simple-markdown\n   * might be able to help.\n   *\n   * Many of the regexes and original logic has been adapted from\n   * the wonderful [marked.js](https://github.com/chjj/marked)\n   *\n   * LICENSE (MIT):\n   * New code copyright (c) 2014-2019 Khan Academy & Aria Buckles.\n   *\n   * Portions adapted from marked.js copyright (c) 2011-2014\n   * Christopher Jeffrey (https://github.com/chjj/).\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a copy\n   * of this software and associated documentation files (the \"Software\"), to deal\n   * in the Software without restriction, including without limitation the rights\n   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   * copies of the Software, and to permit persons to whom the Software is\n   * furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in\n   * all copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n   * THE SOFTWARE.\n   */\n  // Typescript language & simple-markdown.d.ts references:\n  /// <reference lib=\"ES2018\" />\n  /// <reference path=\"../simple-markdown.d.ts\" />\n\n  /*::\n  // Flow Type Definitions:\n  \n  type Capture =\n      Array<string> & {index: number} |\n      Array<string> & {index?: number};\n  \n  type Attr = string | number | boolean | null | void;\n  \n  type SingleASTNode = {\n      type: string,\n      [string]: any,\n  };\n  \n  type UnTypedASTNode = {\n      [string]: any\n  };\n  \n  type ASTNode = SingleASTNode | Array<SingleASTNode>;\n  \n  type State = {\n      key?: string | number | void,\n      inline?: ?boolean,\n      [string]: any,\n  };\n  \n  type ReactElement = React$Element<any>;\n  type ReactElements = React$Node;\n  \n  type MatchFunction = { regex?: RegExp } & (\n      source: string,\n      state: State,\n      prevCapture: string\n  ) => ?Capture;\n  \n  type Parser = (\n      source: string,\n      state?: ?State\n  ) => Array<SingleASTNode>;\n  \n  type ParseFunction = (\n      capture: Capture,\n      nestedParse: Parser,\n      state: State,\n  ) => (UnTypedASTNode | ASTNode);\n  \n  type SingleNodeParseFunction = (\n      capture: Capture,\n      nestedParse: Parser,\n      state: State,\n  ) => UnTypedASTNode;\n  \n  type Output<Result> = (\n      node: ASTNode,\n      state?: ?State\n  ) => Result;\n  \n  type NodeOutput<Result> = (\n      node: SingleASTNode,\n      nestedOutput: Output<Result>,\n      state: State\n  ) => Result;\n  \n  type ArrayNodeOutput<Result> = (\n      node: Array<SingleASTNode>,\n      nestedOutput: Output<Result>,\n      state: State\n  ) => Result;\n  \n  type ReactOutput = Output<ReactElements>;\n  type ReactNodeOutput = NodeOutput<ReactElements>;\n  type HtmlOutput = Output<string>;\n  type HtmlNodeOutput = NodeOutput<string>;\n  \n  type ParserRule = {\n      +order: number,\n      +match: MatchFunction,\n      +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n      +parse: ParseFunction,\n  };\n  \n  type SingleNodeParserRule = {\n      +order: number,\n      +match: MatchFunction,\n      +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n      +parse: SingleNodeParseFunction,\n  };\n  \n  type ReactOutputRule = {\n      // we allow null because some rules are never output results, and that's\n      // legal as long as no parsers return an AST node matching that rule.\n      // We don't use ? because this makes it be explicitly defined as either\n      // a valid function or null, so it can't be forgotten.\n      +react: ReactNodeOutput | null,\n  };\n  \n  type HtmlOutputRule = {\n      +html: HtmlNodeOutput | null,\n  };\n  \n  type ArrayRule = {\n      +react?: ArrayNodeOutput<ReactElements>,\n      +html?: ArrayNodeOutput<string>,\n      +[string]: ArrayNodeOutput<any>,\n  };\n  \n  type ParserRules = {\n      +Array?: ArrayRule,\n      +[type: string]: ParserRule,\n  };\n  \n  type OutputRules<Rule> = {\n      +Array?: ArrayRule,\n      +[type: string]: Rule\n  };\n  type Rules<OutputRule> = {\n      +Array?: ArrayRule,\n      +[type: string]: ParserRule & OutputRule,\n  };\n  type ReactRules = {\n      +Array?: {\n          +react: ArrayNodeOutput<ReactElements>,\n      },\n      +[type: string]: ParserRule & ReactOutputRule,\n  };\n  type HtmlRules = {\n      +Array?: {\n          +html: ArrayNodeOutput<string>,\n      },\n      +[type: string]: ParserRule & HtmlOutputRule,\n  };\n  \n  // We want to clarify our defaultRules types a little bit more so clients can\n  // reuse defaultRules built-ins. So we make some stronger guarantess when\n  // we can:\n  type NonNullReactOutputRule = {\n      +react: ReactNodeOutput,\n  };\n  type ElementReactOutputRule = {\n      +react: NodeOutput<ReactElement>,\n  };\n  type TextReactOutputRule = {\n      +react: NodeOutput<string>,\n  };\n  type NonNullHtmlOutputRule = {\n      +html: HtmlNodeOutput,\n  };\n  \n  type DefaultInRule = SingleNodeParserRule & ReactOutputRule & HtmlOutputRule;\n  type TextInOutRule = SingleNodeParserRule & TextReactOutputRule & NonNullHtmlOutputRule;\n  type LenientInOutRule = SingleNodeParserRule & NonNullReactOutputRule & NonNullHtmlOutputRule;\n  type DefaultInOutRule = SingleNodeParserRule & ElementReactOutputRule & NonNullHtmlOutputRule;\n  \n  type DefaultRules = {\n      +Array: {\n          +react: ArrayNodeOutput<ReactElements>,\n          +html: ArrayNodeOutput<string>\n      },\n      +heading: DefaultInOutRule,\n      +nptable: DefaultInRule,\n      +lheading: DefaultInRule,\n      +hr: DefaultInOutRule,\n      +codeBlock: DefaultInOutRule,\n      +fence: DefaultInRule,\n      +blockQuote: DefaultInOutRule,\n      +list: DefaultInOutRule,\n      +def: LenientInOutRule,\n      +table: DefaultInOutRule,\n      +tableSeparator: DefaultInRule,\n      +newline: TextInOutRule,\n      +paragraph: DefaultInOutRule,\n      +escape: DefaultInRule,\n      +autolink: DefaultInRule,\n      +mailto: DefaultInRule,\n      +url: DefaultInRule,\n      +link: DefaultInOutRule,\n      +image: DefaultInOutRule,\n      +reflink: DefaultInRule,\n      +refimage: DefaultInRule,\n      +em: DefaultInOutRule,\n      +strong: DefaultInOutRule,\n      +u: DefaultInOutRule,\n      +del: DefaultInOutRule,\n      +inlineCode: DefaultInOutRule,\n      +br: DefaultInOutRule,\n      +text: TextInOutRule,\n  };\n  \n  type RefNode = {\n      type: string,\n      content?: ASTNode,\n      target?: string,\n      title?: string,\n      alt?: string,\n  };\n  \n  // End Flow Definitions\n  */\n\n  var CR_NEWLINE_R = /\\r\\n?/g;\n  var TAB_R = /\\t/g;\n  var FORMFEED_R = /\\f/g;\n  /**\n   * Turn various whitespace into easy-to-process whitespace\n   * @param {string} source\n   * @returns {string}\n   */\n\n  var preprocess = function preprocess(source\n  /* : string */\n  ) {\n    return source.replace(CR_NEWLINE_R, '\\n').replace(FORMFEED_R, '').replace(TAB_R, '    ');\n  };\n  /**\n   * @param {SimpleMarkdown.OptionalState} givenState\n   * @param {SimpleMarkdown.OptionalState} defaultState\n   * @returns {SimpleMarkdown.State}\n   */\n\n\n  var populateInitialState = function populateInitialState(givenState\n  /* : ?State */\n  , defaultState\n  /* : ?State */\n  )\n  /* : State */\n  {\n    var state\n    /* : State */\n    = givenState || {};\n\n    if (defaultState != null) {\n      for (var prop in defaultState) {\n        if (Object.prototype.hasOwnProperty.call(defaultState, prop)) {\n          state[prop] = defaultState[prop];\n        }\n      }\n    }\n\n    return state;\n  };\n  /**\n   * Creates a parser for a given set of rules, with the precedence\n   * specified as a list of rules.\n   *\n   * @param {SimpleMarkdown.ParserRules} rules\n   *     an object containing\n   *     rule type -> {match, order, parse} objects\n   *     (lower order is higher precedence)\n   * @param {SimpleMarkdown.OptionalState} [defaultState]\n   *\n   * @returns {SimpleMarkdown.Parser}\n   *     The resulting parse function, with the following parameters:\n   *     @source: the input source string to be parsed\n   *     @state: an optional object to be threaded through parse\n   *         calls. Allows clients to add stateful operations to\n   *         parsing, such as keeping track of how many levels deep\n   *         some nesting is. For an example use-case, see passage-ref\n   *         parsing in src/widgets/passage/passage-markdown.jsx\n   */\n\n\n  var parserFor = function parserFor(rules\n  /*: ParserRules */\n  , defaultState\n  /*: ?State */\n  ) {\n    // Sorts rules in order of increasing order, then\n    // ascending rule name in case of ties.\n    var ruleList = Object.keys(rules).filter(function (type) {\n      var rule = rules[type];\n\n      if (rule == null || rule.match == null) {\n        return false;\n      }\n\n      var order = rule.order;\n\n      if ((typeof order !== 'number' || !isFinite(order)) && typeof console !== 'undefined') {\n        console.warn(\"simple-markdown: Invalid order for rule `\" + type + \"`: \" + String(order));\n      }\n\n      return true;\n    });\n    ruleList.sort(function (typeA, typeB) {\n      var ruleA\n      /* : ParserRule */\n      =\n      /** @type {SimpleMarkdown.ParserRule} */\n      rules[typeA]\n      /*:: :any */\n      ;\n      var ruleB\n      /* : ParserRule */\n      =\n      /** @type {SimpleMarkdown.ParserRule} */\n      rules[typeB]\n      /*:: :any */\n      ;\n      var orderA = ruleA.order;\n      var orderB = ruleB.order; // First sort based on increasing order\n\n      if (orderA !== orderB) {\n        return orderA - orderB;\n      }\n\n      var secondaryOrderA = ruleA.quality ? 0 : 1;\n      var secondaryOrderB = ruleB.quality ? 0 : 1;\n\n      if (secondaryOrderA !== secondaryOrderB) {\n        return secondaryOrderA - secondaryOrderB; // Then based on increasing unicode lexicographic ordering\n      } else if (typeA < typeB) {\n        return -1;\n      } else if (typeA > typeB) {\n        return 1;\n      } else {\n        // Rules should never have the same name,\n        // but this is provided for completeness.\n        return 0;\n      }\n    });\n    /** @type {SimpleMarkdown.State} */\n\n    var latestState;\n    /** @type {SimpleMarkdown.Parser} */\n\n    var nestedParse = function nestedParse(source\n    /* : string */\n    , state\n    /* : ?State */\n    ) {\n      /** @type Array<SimpleMarkdown.SingleASTNode> */\n      var result = [];\n      state = state || latestState;\n      latestState = state;\n\n      while (source) {\n        // store the best match, it's rule, and quality:\n        var ruleType = null;\n        var rule = null;\n        var capture = null;\n        var quality = NaN; // loop control variables:\n\n        var i = 0;\n        var currRuleType = ruleList[0];\n        var currRule\n        /* : ParserRule */\n        =\n        /** @type {SimpleMarkdown.ParserRule} */\n        rules[currRuleType]\n        /*:: :any */\n        ;\n\n        do {\n          var currOrder = currRule.order;\n          var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n          var currCapture = currRule.match(source, state, prevCaptureStr);\n\n          if (currCapture) {\n            var currQuality = currRule.quality ? currRule.quality(currCapture, state, prevCaptureStr) : 0; // This should always be true the first time because\n            // the initial quality is NaN (that's why there's the\n            // condition negation).\n\n            if (!(currQuality <= quality)) {\n              ruleType = currRuleType;\n              rule = currRule;\n              capture = currCapture;\n              quality = currQuality;\n            }\n          } // Move on to the next item.\n          // Note that this makes `currRule` be the next item\n\n\n          i++;\n          currRuleType = ruleList[i];\n          currRule =\n          /*::((*/\n\n          /** @type {SimpleMarkdown.ParserRule} */\n          rules[currRuleType]\n          /*:: : any) : ParserRule)*/\n          ;\n        } while ( // keep looping while we're still within the ruleList\n        currRule && ( // if we don't have a match yet, continue\n        !capture || // or if we have a match, but the next rule is\n        // at the same order, and has a quality measurement\n        // functions, then this rule must have a quality\n        // measurement function (since they are sorted before\n        // those without), and we need to check if there is\n        // a better quality match\n        currRule.order === currOrder && currRule.quality)); // TODO(aria): Write tests for these\n\n\n        if (rule == null || capture == null\n        /*:: || ruleType == null */\n        ) {\n            throw new Error(\"Could not find a matching rule for the below \" + \"content. The rule with highest `order` should \" + \"always match content provided to it. Check \" + \"the definition of `match` for '\" + ruleList[ruleList.length - 1] + \"'. It seems to not match the following source:\\n\" + source);\n          }\n\n        if (capture.index) {\n          // If present and non-zero, i.e. a non-^ regexp result:\n          throw new Error(\"`match` must return a capture starting at index 0 \" + \"(the current parse index). Did you forget a ^ at the \" + \"start of the RegExp?\");\n        }\n\n        var parsed = rule.parse(capture, nestedParse, state); // We maintain the same object here so that rules can\n        // store references to the objects they return and\n        // modify them later. (oops sorry! but this adds a lot\n        // of power--see reflinks.)\n\n        if (Array.isArray(parsed)) {\n          Array.prototype.push.apply(result, parsed);\n        } else {\n          // We also let rules override the default type of\n          // their parsed node if they would like to, so that\n          // there can be a single output function for all links,\n          // even if there are several rules to parse them.\n          if (parsed.type == null) {\n            parsed.type = ruleType;\n          }\n\n          result.push(\n          /** @type {SimpleMarkdown.SingleASTNode} */\n          parsed);\n        }\n\n        state.prevCapture = capture;\n        source = source.substring(state.prevCapture[0].length);\n      }\n\n      return result;\n    };\n    /** @type {SimpleMarkdown.Parser} */\n\n\n    var outerParse = function outerParse(source\n    /* : string */\n    , state\n    /* : ?State */\n    ) {\n      latestState = populateInitialState(state, defaultState);\n\n      if (!latestState.inline && !latestState.disableAutoBlockNewlines) {\n        source = source + \"\\n\\n\";\n      } // We store the previous capture so that match functions can\n      // use some limited amount of lookbehind. Lists use this to\n      // ensure they don't match arbitrary '- ' or '* ' in inline\n      // text (see the list rule for more information). This stores\n      // the full regex capture object, if there is one.\n\n\n      latestState.prevCapture = null;\n      return nestedParse(preprocess(source), latestState);\n    };\n\n    return outerParse;\n  }; // Creates a match function for an inline scoped element from a regex\n\n  /** @type {(regex: RegExp) => SimpleMarkdown.MatchFunction} */\n\n\n  var inlineRegex = function inlineRegex(regex\n  /* : RegExp */\n  ) {\n    /** @type {SimpleMarkdown.MatchFunction} */\n    var match\n    /* : MatchFunction */\n    = function match(source, state) {\n      if (state.inline) {\n        return regex.exec(source);\n      } else {\n        return null;\n      }\n    };\n\n    match.regex = regex;\n    return match;\n  }; // Creates a match function for a block scoped element from a regex\n\n  /** @type {(regex: RegExp) => SimpleMarkdown.MatchFunction} */\n\n\n  var blockRegex = function blockRegex(regex\n  /* : RegExp */\n  ) {\n    /** @type {SimpleMarkdown.MatchFunction} */\n    var match\n    /* : MatchFunction */\n    = function match(source, state) {\n      if (state.inline) {\n        return null;\n      } else {\n        return regex.exec(source);\n      }\n    };\n\n    match.regex = regex;\n    return match;\n  }; // Creates a match function from a regex, ignoring block/inline scope\n\n  /** @type {(regex: RegExp) => SimpleMarkdown.MatchFunction} */\n\n\n  var anyScopeRegex = function anyScopeRegex(regex\n  /* : RegExp */\n  ) {\n    /** @type {SimpleMarkdown.MatchFunction} */\n    var match\n    /* : MatchFunction */\n    = function match(source, state) {\n      return regex.exec(source);\n    };\n\n    match.regex = regex;\n    return match;\n  };\n\n  var TYPE_SYMBOL = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;\n  /**\n   * @param {string} type\n   * @param {string | number | null | undefined} key\n   * @param {Object<string, any>} props\n   * @returns {SimpleMarkdown.ReactElement}\n   */\n\n  var reactElement = function reactElement(type\n  /* : string */\n  , key\n  /* : string | number | null | void */\n  , props\n  /* : { [string]: any } */\n  )\n  /* : ReactElement */\n  {\n    var element\n    /* : ReactElement */\n    =\n    /** @type {SimpleMarkdown.ReactElement} */\n    {\n      $$typeof: TYPE_SYMBOL,\n      type: type,\n      key: key == null ? undefined : key,\n      ref: null,\n      props: props,\n      _owner: null\n    }\n    /* : any */\n    ;\n    return element;\n  };\n  /** Returns a closed HTML tag.\n   * @param {string} tagName - Name of HTML tag (eg. \"em\" or \"a\")\n   * @param {string} content - Inner content of tag\n   * @param {{ [attr: string]: SimpleMarkdown.Attr }} [attributes] - Optional extra attributes of tag as an object of key-value pairs\n   *   eg. { \"href\": \"http://google.com\" }. Falsey attributes are filtered out.\n   * @param {boolean} [isClosed] - boolean that controls whether tag is closed or not (eg. img tags).\n   *   defaults to true\n   */\n\n\n  var htmlTag = function htmlTag(tagName\n  /* : string */\n  , content\n  /* : string */\n  , attributes\n  /* : ?{[any]: ?Attr} */\n  , isClosed\n  /* : ?boolean */\n  ) {\n    attributes = attributes || {};\n    isClosed = typeof isClosed !== 'undefined' ? isClosed : true;\n    var attributeString = \"\";\n\n    for (var attr in attributes) {\n      var attribute = attributes[attr]; // Removes falsey attributes\n\n      if (Object.prototype.hasOwnProperty.call(attributes, attr) && attribute) {\n        attributeString += \" \" + sanitizeText(attr) + '=\"' + sanitizeText(attribute) + '\"';\n      }\n    }\n\n    var unclosedTag = \"<\" + tagName + attributeString + \">\";\n\n    if (isClosed) {\n      return unclosedTag + content + \"</\" + tagName + \">\";\n    } else {\n      return unclosedTag;\n    }\n  };\n\n  var EMPTY_PROPS = {};\n  /**\n   * @param {string | null | undefined} url - url to sanitize\n   * @returns {string | null} - url if safe, or null if a safe url could not be made\n   */\n\n  var sanitizeUrl = function sanitizeUrl(url\n  /* : ?string */\n  ) {\n    if (url == null) {\n      return null;\n    }\n\n    try {\n      var prot = decodeURIComponent(url).replace(/[^A-Za-z0-9/:]/g, '').toLowerCase();\n\n      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n        return null;\n      }\n    } catch (e) {\n      // decodeURIComponent sometimes throws a URIError\n      // See `decodeURIComponent('a%AFc');`\n      // http://stackoverflow.com/questions/9064536/javascript-decodeuricomponent-malformed-uri-exception\n      return null;\n    }\n\n    return url;\n  };\n\n  var SANITIZE_TEXT_R = /[<>&\"']/g;\n  /** @type {any} */\n\n  var SANITIZE_TEXT_CODES = {\n    '<': '&lt;',\n    '>': '&gt;',\n    '&': '&amp;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '/': '&#x2F;',\n    \"`\": '&#96;'\n  };\n  /**\n   * @param {SimpleMarkdown.Attr} text\n   * @returns {string}\n   */\n\n  var sanitizeText = function sanitizeText(text\n  /* : Attr */\n  ) {\n    return String(text).replace(SANITIZE_TEXT_R, function (chr) {\n      return SANITIZE_TEXT_CODES[chr];\n    });\n  };\n\n  var UNESCAPE_URL_R = /\\\\([^0-9A-Za-z\\s])/g;\n  /**\n   * @param {string} rawUrlString\n   * @returns {string}\n   */\n\n  var unescapeUrl = function unescapeUrl(rawUrlString\n  /* : string */\n  ) {\n    return rawUrlString.replace(UNESCAPE_URL_R, \"$1\");\n  };\n  /**\n   * Parse some content with the parser `parse`, with state.inline\n   * set to true. Useful for block elements; not generally necessary\n   * to be used by inline elements (where state.inline is already true.\n   *\n   * @param {SimpleMarkdown.Parser} parse\n   * @param {string} content\n   * @param {SimpleMarkdown.State} state\n   * @returns {SimpleMarkdown.ASTNode}\n   */\n\n\n  var parseInline = function parseInline(parse, content, state) {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = true;\n    var result = parse(content, state);\n    state.inline = isCurrentlyInline;\n    return result;\n  };\n  /**\n   * @param {SimpleMarkdown.Parser} parse\n   * @param {string} content\n   * @param {SimpleMarkdown.State} state\n   * @returns {SimpleMarkdown.ASTNode}\n   */\n\n\n  var parseBlock = function parseBlock(parse, content, state) {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = false;\n    var result = parse(content + \"\\n\\n\", state);\n    state.inline = isCurrentlyInline;\n    return result;\n  };\n  /**\n   * @param {SimpleMarkdown.Capture} capture\n   * @param {SimpleMarkdown.Parser} parse\n   * @param {SimpleMarkdown.State} state\n   * @returns {SimpleMarkdown.UnTypedASTNode}\n   */\n\n\n  var parseCaptureInline = function parseCaptureInline(capture, parse, state) {\n    return {\n      content: parseInline(parse, capture[1], state)\n    };\n  };\n  /**\n   * @returns {SimpleMarkdown.UnTypedASTNode}\n   */\n\n\n  var ignoreCapture = function ignoreCapture() {\n    return {};\n  }; // recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\n\n\n  var LIST_BULLET = \"(?:[*+-]|\\\\d+\\\\.)\"; // recognize the start of a list item:\n  // leading space plus a bullet plus a space (`   * `)\n\n  var LIST_ITEM_PREFIX = \"( *)(\" + LIST_BULLET + \") +\";\n  var LIST_ITEM_PREFIX_R = new RegExp(\"^\" + LIST_ITEM_PREFIX); // recognize an individual list item:\n  //  * hi\n  //    this is part of the same item\n  //\n  //    as is this, which is a new paragraph in the same item\n  //\n  //  * but this is not part of the same item\n\n  var LIST_ITEM_R = new RegExp(LIST_ITEM_PREFIX + \"[^\\\\n]*(?:\\\\n\" + \"(?!\\\\1\" + LIST_BULLET + \" )[^\\\\n]*)*(\\n|$)\", \"gm\");\n  var BLOCK_END_R = /\\n{2,}$/;\n  var INLINE_CODE_ESCAPE_BACKTICKS_R = /^ (?= *`)|(` *) $/g; // recognize the end of a paragraph block inside a list item:\n  // two or more newlines at end end of the item\n\n  var LIST_BLOCK_END_R = BLOCK_END_R;\n  var LIST_ITEM_END_R = / *\\n+$/; // check whether a list item has paragraphs: if it does,\n  // we leave the newlines at the end\n\n  var LIST_R = new RegExp(\"^( *)(\" + LIST_BULLET + \") \" + \"[\\\\s\\\\S]+?(?:\\n{2,}(?! )\" + \"(?!\\\\1\" + LIST_BULLET + \" )\\\\n*\" + // the \\\\s*$ here is so that we can parse the inside of nested\n  // lists, where our content might end before we receive two `\\n`s\n  \"|\\\\s*\\n*$)\");\n  var LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/;\n\n  var TABLES = function () {\n    var TABLE_ROW_SEPARATOR_TRIM = /^ *\\| *| *\\| *$/g;\n    var TABLE_CELL_END_TRIM = / *$/;\n    var TABLE_RIGHT_ALIGN = /^ *-+: *$/;\n    var TABLE_CENTER_ALIGN = /^ *:-+: *$/;\n    var TABLE_LEFT_ALIGN = /^ *:-+ *$/;\n    /**\n     * @param {string} alignCapture\n     * @returns {SimpleMarkdown.TableAlignment}\n     */\n\n    var parseTableAlignCapture = function parseTableAlignCapture(alignCapture) {\n      if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n        return \"right\";\n      } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n        return \"center\";\n      } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n        return \"left\";\n      } else {\n        return null;\n      }\n    };\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {Array<SimpleMarkdown.TableAlignment>}\n     */\n\n\n    var parseTableAlign = function parseTableAlign(source, parse, state, trimEndSeparators) {\n      if (trimEndSeparators) {\n        source = source.replace(TABLE_ROW_SEPARATOR_TRIM, \"\");\n      }\n\n      var alignText = source.trim().split(\"|\");\n      return alignText.map(parseTableAlignCapture);\n    };\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.SingleASTNode[][]}\n     */\n\n\n    var parseTableRow = function parseTableRow(source, parse, state, trimEndSeparators) {\n      var prevInTable = state.inTable;\n      state.inTable = true;\n      var tableRow = parse(source.trim(), state);\n      state.inTable = prevInTable;\n      /** @type {SimpleMarkdown.SingleASTNode[][]} */\n\n      var cells = [[]];\n      tableRow.forEach(function (node, i) {\n        if (node.type === 'tableSeparator') {\n          // Filter out empty table separators at the start/end:\n          if (!trimEndSeparators || i !== 0 && i !== tableRow.length - 1) {\n            // Split the current row:\n            cells.push([]);\n          }\n        } else {\n          if (node.type === 'text' && (tableRow[i + 1] == null || tableRow[i + 1].type === 'tableSeparator')) {\n            node.content = node.content.replace(TABLE_CELL_END_TRIM, \"\");\n          }\n\n          cells[cells.length - 1].push(node);\n        }\n      });\n      return cells;\n    };\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.ASTNode[][]}\n     */\n\n\n    var parseTableCells = function parseTableCells(source, parse, state, trimEndSeparators) {\n      var rowsText = source.trim().split(\"\\n\");\n      return rowsText.map(function (rowText) {\n        return parseTableRow(rowText, parse, state, trimEndSeparators);\n      });\n    };\n    /**\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.SingleNodeParseFunction}\n     */\n\n\n    var parseTable = function parseTable(trimEndSeparators) {\n      /** @type {SimpleMarkdown.SingleNodeParseFunction} */\n      return function (capture, parse, state) {\n        state.inline = true;\n        var header = parseTableRow(capture[1], parse, state, trimEndSeparators);\n        var align = parseTableAlign(capture[2], parse, state, trimEndSeparators);\n        var cells = parseTableCells(capture[3], parse, state, trimEndSeparators);\n        state.inline = false;\n        return {\n          type: \"table\",\n          header: header,\n          align: align,\n          cells: cells\n        };\n      };\n    };\n\n    return {\n      parseTable: parseTable(true),\n      parseNpTable: parseTable(false),\n      TABLE_REGEX: /^ *(\\|.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/,\n      NPTABLE_REGEX: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/\n    };\n  }();\n\n  var LINK_INSIDE = \"(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*\";\n  var LINK_HREF_AND_TITLE = \"\\\\s*<?((?:\\\\([^)]*\\\\)|[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\";\n  var AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\n  /**\n   * @param {SimpleMarkdown.Capture} capture\n   * @param {SimpleMarkdown.State} state\n   * @param {SimpleMarkdown.RefNode} refNode\n   * @returns {SimpleMarkdown.RefNode}\n   */\n\n  var parseRef = function parseRef(capture, state, refNode\n  /* : RefNode */\n  ) {\n    var ref = (capture[2] || capture[1]).replace(/\\s+/g, ' ').toLowerCase(); // We store information about previously seen defs on\n    // state._defs (_ to deconflict with client-defined\n    // state). If the def for this reflink/refimage has\n    // already been seen, we can use its target/source\n    // and title here:\n\n    if (state._defs && state._defs[ref]) {\n      var def = state._defs[ref]; // `refNode` can be a link or an image. Both use\n      // target and title properties.\n\n      refNode.target = def.target;\n      refNode.title = def.title;\n    } // In case we haven't seen our def yet (or if someone\n    // overwrites that def later on), we add this node\n    // to the list of ref nodes for that def. Then, when\n    // we find the def, we can modify this link/image AST\n    // node :).\n    // I'm sorry.\n\n\n    state._refs = state._refs || {};\n    state._refs[ref] = state._refs[ref] || [];\n\n    state._refs[ref].push(refNode);\n\n    return refNode;\n  };\n\n  var currOrder = 0;\n  /** @type {SimpleMarkdown.DefaultRules} */\n\n  var defaultRules\n  /* : DefaultRules */\n  = {\n    Array: {\n      react: function react(arr, output, state) {\n        var oldKey = state.key;\n        var result\n        /* : Array<ReactElements> */\n        = []; // map output over the ast, except group any text\n        // nodes together into a single string output.\n\n        for (var i = 0, key = 0; i < arr.length; i++, key++) {\n          // `key` is our numerical `state.key`, which we increment for\n          // every output node, but don't change for joined text nodes.\n          // (i, however, must change for joined text nodes)\n          state.key = '' + i;\n          var node = arr[i];\n\n          if (node.type === 'text') {\n            node = {\n              type: 'text',\n              content: node.content\n            };\n\n            for (; i + 1 < arr.length && arr[i + 1].type === 'text'; i++) {\n              node.content += arr[i + 1].content;\n            }\n          }\n\n          result.push(output(node, state));\n        }\n\n        state.key = oldKey;\n        return result;\n      },\n      html: function html(arr, output, state) {\n        var result = \"\"; // map output over the ast, except group any text\n        // nodes together into a single string output.\n\n        for (var i = 0; i < arr.length; i++) {\n          var node = arr[i];\n\n          if (node.type === 'text') {\n            node = {\n              type: 'text',\n              content: node.content\n            };\n\n            for (; i + 1 < arr.length && arr[i + 1].type === 'text'; i++) {\n              node.content += arr[i + 1].content;\n            }\n          }\n\n          result += output(node, state);\n        }\n\n        return result;\n      }\n    },\n    heading: {\n      order: currOrder++,\n      match: blockRegex(/^ *(#{1,6})([^\\n]+?)#* *(?:\\n *)+\\n/),\n      parse: function parse(capture, _parse, state) {\n        return {\n          level: capture[1].length,\n          content: parseInline(_parse, capture[2].trim(), state)\n        };\n      },\n      react: function react(node, output, state) {\n        return reactElement('h' + node.level, state.key, {\n          children: output(node.content, state)\n        });\n      },\n      html: function html(node, output, state) {\n        return htmlTag(\"h\" + node.level, output(node.content, state));\n      }\n    },\n    nptable: {\n      order: currOrder++,\n      match: blockRegex(TABLES.NPTABLE_REGEX),\n      parse: TABLES.parseNpTable,\n      react: null,\n      html: null\n    },\n    lheading: {\n      order: currOrder++,\n      match: blockRegex(/^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/),\n      parse: function parse(capture, _parse2, state) {\n        return {\n          type: \"heading\",\n          level: capture[2] === '=' ? 1 : 2,\n          content: parseInline(_parse2, capture[1], state)\n        };\n      },\n      react: null,\n      html: null\n    },\n    hr: {\n      order: currOrder++,\n      match: blockRegex(/^( *[-*_]){3,} *(?:\\n *)+\\n/),\n      parse: ignoreCapture,\n      react: function react(node, output, state) {\n        return reactElement('hr', state.key, EMPTY_PROPS);\n      },\n      html: function html(node, output, state) {\n        return \"<hr>\";\n      }\n    },\n    codeBlock: {\n      order: currOrder++,\n      match: blockRegex(/^(?:    [^\\n]+\\n*)+(?:\\n *)+\\n/),\n      parse: function parse(capture, _parse3, state) {\n        var content = capture[0].replace(/^    /gm, '').replace(/\\n+$/, '');\n        return {\n          lang: undefined,\n          content: content\n        };\n      },\n      react: function react(node, output, state) {\n        var className = node.lang ? \"markdown-code-\" + node.lang : undefined;\n        return reactElement('pre', state.key, {\n          children: reactElement('code', null, {\n            className: className,\n            children: node.content\n          })\n        });\n      },\n      html: function html(node, output, state) {\n        var className = node.lang ? \"markdown-code-\" + node.lang : undefined;\n        var codeBlock = htmlTag(\"code\", sanitizeText(node.content), {\n          class: className\n        });\n        return htmlTag(\"pre\", codeBlock);\n      }\n    },\n    fence: {\n      order: currOrder++,\n      match: blockRegex(/^ *(`{3,}|~{3,}) *(?:(\\S+) *)?\\n([\\s\\S]+?)\\n?\\1 *(?:\\n *)+\\n/),\n      parse: function parse(capture, _parse4, state) {\n        return {\n          type: \"codeBlock\",\n          lang: capture[2] || undefined,\n          content: capture[3]\n        };\n      },\n      react: null,\n      html: null\n    },\n    blockQuote: {\n      order: currOrder++,\n      match: blockRegex(/^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/),\n      parse: function parse(capture, _parse5, state) {\n        var content = capture[0].replace(/^ *> ?/gm, '');\n        return {\n          content: _parse5(content, state)\n        };\n      },\n      react: function react(node, output, state) {\n        return reactElement('blockquote', state.key, {\n          children: output(node.content, state)\n        });\n      },\n      html: function html(node, output, state) {\n        return htmlTag(\"blockquote\", output(node.content, state));\n      }\n    },\n    list: {\n      order: currOrder++,\n      match: function match(source, state) {\n        // We only want to break into a list if we are at the start of a\n        // line. This is to avoid parsing \"hi * there\" with \"* there\"\n        // becoming a part of a list.\n        // You might wonder, \"but that's inline, so of course it wouldn't\n        // start a list?\". You would be correct! Except that some of our\n        // lists can be inline, because they might be inside another list,\n        // in which case we can parse with inline scope, but need to allow\n        // nested lists inside this inline scope.\n        var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n        var isStartOfLineCapture = LIST_LOOKBEHIND_R.exec(prevCaptureStr);\n        var isListBlock = state._list || !state.inline;\n\n        if (isStartOfLineCapture && isListBlock) {\n          source = isStartOfLineCapture[1] + source;\n          return LIST_R.exec(source);\n        } else {\n          return null;\n        }\n      },\n      parse: function parse(capture, _parse6, state) {\n        var bullet = capture[2];\n        var ordered = bullet.length > 1;\n        var start = ordered ? +bullet : undefined;\n        var items =\n        /** @type {string[]} */\n        capture[0].replace(LIST_BLOCK_END_R, \"\\n\").match(LIST_ITEM_R); // We know this will match here, because of how the regexes are\n        // defined\n\n        /*:: items = ((items : any) : Array<string>) */\n\n        var lastItemWasAParagraph = false;\n        var itemContent = items.map(function (\n        /** @type {string} */\n        item,\n        /** @type {number} */\n        i) {\n          // We need to see how far indented this item is:\n          var prefixCapture = LIST_ITEM_PREFIX_R.exec(item);\n          var space = prefixCapture ? prefixCapture[0].length : 0; // And then we construct a regex to \"unindent\" the subsequent\n          // lines of the items by that amount:\n\n          var spaceRegex = new RegExp(\"^ {1,\" + space + \"}\", \"gm\"); // Before processing the item, we need a couple things\n\n          var content = item // remove indents on trailing lines:\n          .replace(spaceRegex, '') // remove the bullet:\n          .replace(LIST_ITEM_PREFIX_R, ''); // I'm not sur4 why this is necessary again?\n\n          /*:: items = ((items : any) : Array<string>) */\n          // Handling \"loose\" lists, like:\n          //\n          //  * this is wrapped in a paragraph\n          //\n          //  * as is this\n          //\n          //  * as is this\n\n          var isLastItem = i === items.length - 1;\n          var containsBlocks = content.indexOf(\"\\n\\n\") !== -1; // Any element in a list is a block if it contains multiple\n          // newlines. The last element in the list can also be a block\n          // if the previous item in the list was a block (this is\n          // because non-last items in the list can end with \\n\\n, but\n          // the last item can't, so we just \"inherit\" this property\n          // from our previous element).\n\n          var thisItemIsAParagraph = containsBlocks || isLastItem && lastItemWasAParagraph;\n          lastItemWasAParagraph = thisItemIsAParagraph; // backup our state for restoration afterwards. We're going to\n          // want to set state._list to true, and state.inline depending\n          // on our list's looseness.\n\n          var oldStateInline = state.inline;\n          var oldStateList = state._list;\n          state._list = true; // Parse inline if we're in a tight list, or block if we're in\n          // a loose list.\n\n          var adjustedContent;\n\n          if (thisItemIsAParagraph) {\n            state.inline = false;\n            adjustedContent = content.replace(LIST_ITEM_END_R, \"\\n\\n\");\n          } else {\n            state.inline = true;\n            adjustedContent = content.replace(LIST_ITEM_END_R, \"\");\n          }\n\n          var result = _parse6(adjustedContent, state); // Restore our state before returning\n\n\n          state.inline = oldStateInline;\n          state._list = oldStateList;\n          return result;\n        });\n        return {\n          ordered: ordered,\n          start: start,\n          items: itemContent\n        };\n      },\n      react: function react(node, output, state) {\n        var ListWrapper = node.ordered ? \"ol\" : \"ul\";\n        return reactElement(ListWrapper, state.key, {\n          start: node.start,\n          children: node.items.map(function (\n          /** @type {SimpleMarkdown.ASTNode} */\n          item,\n          /** @type {number} */\n          i) {\n            return reactElement('li', '' + i, {\n              children: output(item, state)\n            });\n          })\n        });\n      },\n      html: function html(node, output, state) {\n        var listItems = node.items.map(function (\n        /** @type {SimpleMarkdown.ASTNode} */\n        item) {\n          return htmlTag(\"li\", output(item, state));\n        }).join(\"\");\n        var listTag = node.ordered ? \"ol\" : \"ul\";\n        var attributes = {\n          start: node.start\n        };\n        return htmlTag(listTag, listItems, attributes);\n      }\n    },\n    def: {\n      order: currOrder++,\n      // TODO(aria): This will match without a blank line before the next\n      // block element, which is inconsistent with most of the rest of\n      // simple-markdown.\n      match: blockRegex(/^ *\\[([^\\]]+)\\]: *<?([^\\s>]*)>?(?: +[\"(]([^\\n]+)[\")])? *\\n(?: *\\n)*/),\n      parse: function parse(capture, _parse7, state) {\n        var def = capture[1].replace(/\\s+/g, ' ').toLowerCase();\n        var target = capture[2];\n        var title = capture[3]; // Look for previous links/images using this def\n        // If any links/images using this def have already been declared,\n        // they will have added themselves to the state._refs[def] list\n        // (_ to deconflict with client-defined state). We look through\n        // that list of reflinks for this def, and modify those AST nodes\n        // with our newly found information now.\n        // Sorry :(.\n\n        if (state._refs && state._refs[def]) {\n          // `refNode` can be a link or an image\n          state._refs[def].forEach(function (\n          /** @type {SimpleMarkdown.RefNode} */\n          refNode) {\n            refNode.target = target;\n            refNode.title = title;\n          });\n        } // Add this def to our map of defs for any future links/images\n        // In case we haven't found any or all of the refs referring to\n        // this def yet, we add our def to the table of known defs, so\n        // that future reflinks can modify themselves appropriately with\n        // this information.\n\n\n        state._defs = state._defs || {};\n        state._defs[def] = {\n          target: target,\n          title: title\n        }; // return the relevant parsed information\n        // for debugging only.\n\n        return {\n          def: def,\n          target: target,\n          title: title\n        };\n      },\n      react: function react() {\n        return null;\n      },\n      html: function html() {\n        return \"\";\n      }\n    },\n    table: {\n      order: currOrder++,\n      match: blockRegex(TABLES.TABLE_REGEX),\n      parse: TABLES.parseTable,\n      react: function react(node, output, state) {\n        /**\n         * @param {number} colIndex\n         * @returns {{ [attr: string]: SimpleMarkdown.Attr }}\n         */\n        var getStyle = function getStyle(colIndex) {\n          return node.align[colIndex] == null ? {} : {\n            textAlign: node.align[colIndex]\n          };\n        };\n\n        var headers = node.header.map(function (\n        /** @type {SimpleMarkdown.ASTNode} */\n        content,\n        /** @type {number} */\n        i) {\n          return reactElement('th', '' + i, {\n            style: getStyle(i),\n            scope: 'col',\n            children: output(content, state)\n          });\n        });\n        var rows = node.cells.map(function (\n        /** @type {SimpleMarkdown.ASTNode[]} */\n        row,\n        /** @type {number} */\n        r) {\n          return reactElement('tr', '' + r, {\n            children: row.map(function (\n            /** @type {SimpleMarkdown.ASTNode} */\n            content,\n            /** @type {number} */\n            c) {\n              return reactElement('td', '' + c, {\n                style: getStyle(c),\n                children: output(content, state)\n              });\n            })\n          });\n        });\n        return reactElement('table', state.key, {\n          children: [reactElement('thead', 'thead', {\n            children: reactElement('tr', null, {\n              children: headers\n            })\n          }), reactElement('tbody', 'tbody', {\n            children: rows\n          })]\n        });\n      },\n      html: function html(node, output, state) {\n        /**\n         * @param {number} colIndex\n         * @returns {string}\n         */\n        var getStyle = function getStyle(colIndex) {\n          return node.align[colIndex] == null ? \"\" : \"text-align:\" + node.align[colIndex] + \";\";\n        };\n\n        var headers = node.header.map(function (\n        /** @type {SimpleMarkdown.ASTNode} */\n        content,\n        /** @type {number} */\n        i) {\n          return htmlTag(\"th\", output(content, state), {\n            style: getStyle(i),\n            scope: \"col\"\n          });\n        }).join(\"\");\n        var rows = node.cells.map(function (\n        /** @type {SimpleMarkdown.ASTNode[]} */\n        row) {\n          var cols = row.map(function (\n          /** @type {SimpleMarkdown.ASTNode} */\n          content,\n          /** @type {number} */\n          c) {\n            return htmlTag(\"td\", output(content, state), {\n              style: getStyle(c)\n            });\n          }).join(\"\");\n          return htmlTag(\"tr\", cols);\n        }).join(\"\");\n        var thead = htmlTag(\"thead\", htmlTag(\"tr\", headers));\n        var tbody = htmlTag(\"tbody\", rows);\n        return htmlTag(\"table\", thead + tbody);\n      }\n    },\n    newline: {\n      order: currOrder++,\n      match: blockRegex(/^(?:\\n *)*\\n/),\n      parse: ignoreCapture,\n      react: function react(node, output, state) {\n        return \"\\n\";\n      },\n      html: function html(node, output, state) {\n        return \"\\n\";\n      }\n    },\n    paragraph: {\n      order: currOrder++,\n      match: blockRegex(/^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/),\n      parse: parseCaptureInline,\n      react: function react(node, output, state) {\n        return reactElement('div', state.key, {\n          className: 'paragraph',\n          children: output(node.content, state)\n        });\n      },\n      html: function html(node, output, state) {\n        var attributes = {\n          class: 'paragraph'\n        };\n        return htmlTag(\"div\", output(node.content, state), attributes);\n      }\n    },\n    escape: {\n      order: currOrder++,\n      // We don't allow escaping numbers, letters, or spaces here so that\n      // backslashes used in plain text still get rendered. But allowing\n      // escaping anything else provides a very flexible escape mechanism,\n      // regardless of how this grammar is extended.\n      match: inlineRegex(/^\\\\([^0-9A-Za-z\\s])/),\n      parse: function parse(capture, _parse8, state) {\n        return {\n          type: \"text\",\n          content: capture[1]\n        };\n      },\n      react: null,\n      html: null\n    },\n    tableSeparator: {\n      order: currOrder++,\n      match: function match(source, state) {\n        if (!state.inTable) {\n          return null;\n        }\n\n        return /^ *\\| */.exec(source);\n      },\n      parse: function parse() {\n        return {\n          type: 'tableSeparator'\n        };\n      },\n      // These shouldn't be reached, but in case they are, be reasonable:\n      react: function react() {\n        return ' | ';\n      },\n      html: function html() {\n        return ' &vert; ';\n      }\n    },\n    autolink: {\n      order: currOrder++,\n      match: inlineRegex(/^<([^: >]+:\\/[^ >]+)>/),\n      parse: function parse(capture, _parse9, state) {\n        return {\n          type: \"link\",\n          content: [{\n            type: \"text\",\n            content: capture[1]\n          }],\n          target: capture[1]\n        };\n      },\n      react: null,\n      html: null\n    },\n    mailto: {\n      order: currOrder++,\n      match: inlineRegex(/^<([^ >]+@[^ >]+)>/),\n      parse: function parse(capture, _parse10, state) {\n        var address = capture[1];\n        var target = capture[1]; // Check for a `mailto:` already existing in the link:\n\n        if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n          target = \"mailto:\" + target;\n        }\n\n        return {\n          type: \"link\",\n          content: [{\n            type: \"text\",\n            content: address\n          }],\n          target: target\n        };\n      },\n      react: null,\n      html: null\n    },\n    url: {\n      order: currOrder++,\n      match: inlineRegex(/^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/),\n      parse: function parse(capture, _parse11, state) {\n        return {\n          type: \"link\",\n          content: [{\n            type: \"text\",\n            content: capture[1]\n          }],\n          target: capture[1],\n          title: undefined\n        };\n      },\n      react: null,\n      html: null\n    },\n    link: {\n      order: currOrder++,\n      match: inlineRegex(new RegExp(\"^\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\")),\n      parse: function parse(capture, _parse12, state) {\n        var link = {\n          content: _parse12(capture[1], state),\n          target: unescapeUrl(capture[2]),\n          title: capture[3]\n        };\n        return link;\n      },\n      react: function react(node, output, state) {\n        return reactElement('a', state.key, {\n          href: sanitizeUrl(node.target),\n          title: node.title,\n          children: output(node.content, state)\n        });\n      },\n      html: function html(node, output, state) {\n        var attributes = {\n          href: sanitizeUrl(node.target),\n          title: node.title\n        };\n        return htmlTag(\"a\", output(node.content, state), attributes);\n      }\n    },\n    image: {\n      order: currOrder++,\n      match: inlineRegex(new RegExp(\"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\")),\n      parse: function parse(capture, _parse13, state) {\n        var image = {\n          alt: capture[1],\n          target: unescapeUrl(capture[2]),\n          title: capture[3]\n        };\n        return image;\n      },\n      react: function react(node, output, state) {\n        return reactElement('img', state.key, {\n          src: sanitizeUrl(node.target),\n          alt: node.alt,\n          title: node.title\n        });\n      },\n      html: function html(node, output, state) {\n        var attributes = {\n          src: sanitizeUrl(node.target),\n          alt: node.alt,\n          title: node.title\n        };\n        return htmlTag(\"img\", \"\", attributes, false);\n      }\n    },\n    reflink: {\n      order: currOrder++,\n      match: inlineRegex(new RegExp( // The first [part] of the link\n      \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\" + // The [ref] target of the link\n      \"\\\\s*\\\\[([^\\\\]]*)\\\\]\")),\n      parse: function parse(capture, _parse14, state) {\n        return parseRef(capture, state, {\n          type: \"link\",\n          content: _parse14(capture[1], state)\n        });\n      },\n      react: null,\n      html: null\n    },\n    refimage: {\n      order: currOrder++,\n      match: inlineRegex(new RegExp( // The first [part] of the link\n      \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\" + // The [ref] target of the link\n      \"\\\\s*\\\\[([^\\\\]]*)\\\\]\")),\n      parse: function parse(capture, _parse15, state) {\n        return parseRef(capture, state, {\n          type: \"image\",\n          alt: capture[1]\n        });\n      },\n      react: null,\n      html: null\n    },\n    em: {\n      order: currOrder\n      /* same as strong/u */\n      ,\n      match: inlineRegex(new RegExp( // only match _s surrounding words.\n      \"^\\\\b_\" + \"((?:__|\\\\\\\\[\\\\s\\\\S]|[^\\\\\\\\_])+?)_\" + \"\\\\b\" + // Or match *s:\n      \"|\" + // Only match *s that are followed by a non-space:\n      \"^\\\\*(?=\\\\S)(\" + // Match at least one of:\n      \"(?:\" + //  - `**`: so that bolds inside italics don't close the\n      //          italics\n      \"\\\\*\\\\*|\" + //  - escape sequence: so escaped *s don't close us\n      \"\\\\\\\\[\\\\s\\\\S]|\" + //  - whitespace: followed by a non-* (we don't\n      //          want ' *' to close an italics--it might\n      //          start a list)\n      \"\\\\s+(?:\\\\\\\\[\\\\s\\\\S]|[^\\\\s\\\\*\\\\\\\\]|\\\\*\\\\*)|\" + //  - non-whitespace, non-*, non-backslash characters\n      \"[^\\\\s\\\\*\\\\\\\\]\" + \")+?\" + // followed by a non-space, non-* then *\n      \")\\\\*(?!\\\\*)\")),\n      quality: function quality(capture) {\n        // precedence by length, `em` wins ties:\n        return capture[0].length + 0.2;\n      },\n      parse: function parse(capture, _parse16, state) {\n        return {\n          content: _parse16(capture[2] || capture[1], state)\n        };\n      },\n      react: function react(node, output, state) {\n        return reactElement('em', state.key, {\n          children: output(node.content, state)\n        });\n      },\n      html: function html(node, output, state) {\n        return htmlTag(\"em\", output(node.content, state));\n      }\n    },\n    strong: {\n      order: currOrder\n      /* same as em */\n      ,\n      match: inlineRegex(/^\\*\\*((?:\\\\[\\s\\S]|[^\\\\])+?)\\*\\*(?!\\*)/),\n      quality: function quality(capture) {\n        // precedence by length, wins ties vs `u`:\n        return capture[0].length + 0.1;\n      },\n      parse: parseCaptureInline,\n      react: function react(node, output, state) {\n        return reactElement('strong', state.key, {\n          children: output(node.content, state)\n        });\n      },\n      html: function html(node, output, state) {\n        return htmlTag(\"strong\", output(node.content, state));\n      }\n    },\n    u: {\n      order: currOrder++\n      /* same as em&strong; increment for next rule */\n      ,\n      match: inlineRegex(/^__((?:\\\\[\\s\\S]|[^\\\\])+?)__(?!_)/),\n      quality: function quality(capture) {\n        // precedence by length, loses all ties\n        return capture[0].length;\n      },\n      parse: parseCaptureInline,\n      react: function react(node, output, state) {\n        return reactElement('u', state.key, {\n          children: output(node.content, state)\n        });\n      },\n      html: function html(node, output, state) {\n        return htmlTag(\"u\", output(node.content, state));\n      }\n    },\n    del: {\n      order: currOrder++,\n      match: inlineRegex(/^~~(?=\\S)((?:\\\\[\\s\\S]|~(?!~)|[^\\s~]|\\s(?!~~))+?)~~/),\n      parse: parseCaptureInline,\n      react: function react(node, output, state) {\n        return reactElement('del', state.key, {\n          children: output(node.content, state)\n        });\n      },\n      html: function html(node, output, state) {\n        return htmlTag(\"del\", output(node.content, state));\n      }\n    },\n    inlineCode: {\n      order: currOrder++,\n      match: inlineRegex(/^(`+)([\\s\\S]*?[^`])\\1(?!`)/),\n      parse: function parse(capture, _parse17, state) {\n        return {\n          content: capture[2].replace(INLINE_CODE_ESCAPE_BACKTICKS_R, \"$1\")\n        };\n      },\n      react: function react(node, output, state) {\n        return reactElement('code', state.key, {\n          children: node.content\n        });\n      },\n      html: function html(node, output, state) {\n        return htmlTag(\"code\", sanitizeText(node.content));\n      }\n    },\n    br: {\n      order: currOrder++,\n      match: anyScopeRegex(/^ {2,}\\n/),\n      parse: ignoreCapture,\n      react: function react(node, output, state) {\n        return reactElement('br', state.key, EMPTY_PROPS);\n      },\n      html: function html(node, output, state) {\n        return \"<br>\";\n      }\n    },\n    text: {\n      order: currOrder++,\n      // Here we look for anything followed by non-symbols,\n      // double newlines, or double-space-newlines\n      // We break on any symbol characters so that this grammar\n      // is easy to extend without needing to modify this regex\n      match: anyScopeRegex(/^[\\s\\S]+?(?=[^0-9A-Za-z\\s\\u00c0-\\uffff]|\\n\\n| {2,}\\n|\\w+:\\S|$)/),\n      parse: function parse(capture, _parse18, state) {\n        return {\n          content: capture[0]\n        };\n      },\n      react: function react(node, output, state) {\n        return node.content;\n      },\n      html: function html(node, output, state) {\n        return sanitizeText(node.content);\n      }\n    }\n  };\n  /** (deprecated)\n   * @param {any} rules\n   * @param {any} property\n   * @returns {any}\n   */\n\n  var ruleOutput = function ruleOutput(\n  /* :: <Rule : Object> */\n  rules\n  /* : OutputRules<Rule> */\n  , property\n  /* : $Keys<Rule> */\n  ) {\n    if (!property && typeof console !== \"undefined\") {\n      console.warn(\"simple-markdown ruleOutput should take 'react' or \" + \"'html' as the second argument.\");\n    }\n    /** @type {SimpleMarkdown.NodeOutput<any>} */\n\n\n    var nestedRuleOutput\n    /* : NodeOutput<any> */\n    = function nestedRuleOutput(ast\n    /* : SingleASTNode */\n    , outputFunc\n    /* : Output<any> */\n    , state\n    /* : State */\n    ) {\n      return rules[ast.type][property](ast, outputFunc, state);\n    };\n\n    return nestedRuleOutput;\n  };\n  /** (deprecated)\n   * @param {any} outputFunc\n   * @returns {any}\n   */\n\n\n  var reactFor = function reactFor(outputFunc\n  /* : ReactNodeOutput */\n  )\n  /* : ReactOutput */\n  {\n    /** @type {SimpleMarkdown.ReactOutput} */\n    var nestedOutput\n    /* : ReactOutput */\n    = function nestedOutput(ast, state) {\n      state = state || {};\n\n      if (Array.isArray(ast)) {\n        var oldKey = state.key;\n        var result\n        /* : Array<ReactElements> */\n        = []; // map nestedOutput over the ast, except group any text\n        // nodes together into a single string output.\n\n        var lastResult = null;\n\n        for (var i = 0; i < ast.length; i++) {\n          state.key = '' + i;\n          var nodeOut = nestedOutput(ast[i], state);\n\n          if (typeof nodeOut === \"string\" && typeof lastResult === \"string\") {\n            lastResult = lastResult + nodeOut;\n            result[result.length - 1] = lastResult;\n          } else {\n            result.push(nodeOut);\n            lastResult = nodeOut;\n          }\n        }\n\n        state.key = oldKey;\n        return result;\n      } else {\n        return outputFunc(ast, nestedOutput, state);\n      }\n    };\n\n    return nestedOutput;\n  };\n  /** (deprecated)\n   * @param {any} outputFunc\n   * @returns {any}\n   */\n\n\n  var htmlFor = function htmlFor(outputFunc\n  /* : HtmlNodeOutput */\n  )\n  /* : HtmlOutput */\n  {\n    /** @type {SimpleMarkdown.HtmlOutput} */\n    var nestedOutput\n    /* : HtmlOutput */\n    = function nestedOutput(ast, state) {\n      state = state || {};\n\n      if (Array.isArray(ast)) {\n        return ast.map(function (node) {\n          return nestedOutput(node, state);\n        }).join(\"\");\n      } else {\n        return outputFunc(ast, nestedOutput, state);\n      }\n    };\n\n    return nestedOutput;\n  };\n  /**\n   * @type {SimpleMarkdown.OutputFor}\n   */\n\n\n  var outputFor = function outputFor(\n  /* :: <Rule : Object> */\n  rules\n  /* : OutputRules<Rule> */\n  , property\n  /* : $Keys<Rule> */\n  , defaultState\n  /* : ?State */\n  ) {\n    if (!property) {\n      throw new Error('simple-markdown: outputFor: `property` must be ' + 'defined. ' + 'if you just upgraded, you probably need to replace `outputFor` ' + 'with `reactFor`');\n    }\n    /** @type {SimpleMarkdown.State} */\n\n\n    var latestState;\n    /** @type {SimpleMarkdown.ArrayRule} */\n\n    var arrayRule = rules.Array || defaultRules.Array; // Tricks to convince tsc that this var is not null:\n\n    var arrayRuleCheck = arrayRule[property];\n\n    if (!arrayRuleCheck) {\n      throw new Error('simple-markdown: outputFor: to join nodes of type `' + property + '` you must provide an `Array:` joiner rule with that type, ' + 'Please see the docs for details on specifying an Array rule.');\n    }\n\n    var arrayRuleOutput = arrayRuleCheck;\n    /** @type {SimpleMarkdown.Output<any>} */\n\n    var nestedOutput\n    /* : Output<any> */\n    = function nestedOutput(ast, state) {\n      state = state || latestState;\n      latestState = state;\n\n      if (Array.isArray(ast)) {\n        return arrayRuleOutput(ast, nestedOutput, state);\n      } else {\n        return rules[ast.type][property](ast, nestedOutput, state);\n      }\n    };\n    /** @type {SimpleMarkdown.Output<any>} */\n\n\n    var outerOutput = function outerOutput(ast, state) {\n      latestState = populateInitialState(state, defaultState);\n      return nestedOutput(ast, latestState);\n    };\n\n    return outerOutput;\n  };\n\n  var defaultRawParse = parserFor(defaultRules);\n  /**\n   * @param {string} source\n   * @param {SimpleMarkdown.OptionalState} [state]\n   * @returns {Array<SimpleMarkdown.SingleASTNode>}\n   */\n\n  var defaultBlockParse = function defaultBlockParse(source, state) {\n    state = state || {};\n    state.inline = false;\n    return defaultRawParse(source, state);\n  };\n  /**\n   * @param {string} source\n   * @param {SimpleMarkdown.OptionalState} [state]\n   * @returns {Array<SimpleMarkdown.SingleASTNode>}\n   */\n\n\n  var defaultInlineParse = function defaultInlineParse(source, state) {\n    state = state || {};\n    state.inline = true;\n    return defaultRawParse(source, state);\n  };\n  /**\n   * @param {string} source\n   * @param {SimpleMarkdown.OptionalState} [state]\n   * @returns {Array<SimpleMarkdown.SingleASTNode>}\n   */\n\n\n  var defaultImplicitParse = function defaultImplicitParse(source, state) {\n    var isBlock = BLOCK_END_R.test(source);\n    state = state || {};\n    state.inline = !isBlock;\n    return defaultRawParse(source, state);\n  };\n  /** @type {SimpleMarkdown.ReactOutput} */\n\n\n  var defaultReactOutput\n  /* : ReactOutput */\n  = outputFor(defaultRules, \"react\");\n  /** @type {SimpleMarkdown.HtmlOutput} */\n\n  var defaultHtmlOutput\n  /* : HtmlOutput */\n  = outputFor(defaultRules, \"html\");\n  /**\n   * @param {string} source\n   * @param {SimpleMarkdown.OptionalState} [state]\n   * @returns {SimpleMarkdown.ReactElements}\n   */\n\n  var markdownToReact = function markdownToReact(source, state)\n  /* : ReactElements */\n  {\n    return defaultReactOutput(defaultBlockParse(source, state), state);\n  };\n  /**\n   * @param {string} source\n   * @param {SimpleMarkdown.OptionalState} [state]\n   * @returns {string}\n   */\n\n\n  var markdownToHtml = function markdownToHtml(source, state)\n  /* : string */\n  {\n    return defaultHtmlOutput(defaultBlockParse(source, state), state);\n  };\n  /**\n   * @param {SimpleMarkdown.ReactMarkdownProps} props\n   * @returns {SimpleMarkdown.ReactElement}\n   */\n\n\n  var ReactMarkdown = function ReactMarkdown(props) {\n    /** @type {Object} */\n    var divProps = {};\n\n    for (var prop in props) {\n      if (prop !== 'source' && Object.prototype.hasOwnProperty.call(props, prop)) {\n        divProps[prop] = props[prop];\n      }\n    }\n\n    divProps.children = markdownToReact(props.source);\n    return reactElement('div', null, divProps);\n  };\n  /*:: // Flow exports:\n  type Exports = {\n      +defaultRules: DefaultRules,\n      +parserFor: (rules: ParserRules, defaultState?: ?State) => Parser,\n      +outputFor: <Rule : Object>(rules: OutputRules<Rule>, param: $Keys<Rule>, defaultState?: ?State) => Output<any>,\n  \n      +ruleOutput: <Rule : Object>(rules: OutputRules<Rule>, param: $Keys<Rule>) => NodeOutput<any>,\n      +reactFor: (ReactNodeOutput) => ReactOutput,\n      +htmlFor: (HtmlNodeOutput) => HtmlOutput,\n  \n      +inlineRegex: (regex: RegExp) => MatchFunction,\n      +blockRegex: (regex: RegExp) => MatchFunction,\n      +anyScopeRegex: (regex: RegExp) => MatchFunction,\n      +parseInline: (parse: Parser, content: string, state: State) => ASTNode,\n      +parseBlock: (parse: Parser, content: string, state: State) => ASTNode,\n  \n      +markdownToReact: (source: string, state?: ?State) => ReactElements,\n      +markdownToHtml: (source: string, state?: ?State) => string,\n      +ReactMarkdown: (props: { source: string, [string]: any }) => ReactElement,\n  \n      +defaultRawParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n      +defaultBlockParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n      +defaultInlineParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n      +defaultImplicitParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n  \n      +defaultReactOutput: ReactOutput,\n      +defaultHtmlOutput: HtmlOutput,\n  \n      +preprocess: (source: string) => string,\n      +sanitizeText: (text: Attr) => string,\n      +sanitizeUrl: (url: ?string) => ?string,\n      +unescapeUrl: (url: string) => string,\n      +htmlTag: (tagName: string, content: string, attributes: ?{ [any]: ?Attr }, isClosed: ?boolean) => string,\n      +reactElement: (type: string, key: string | null, props: { [string]: any }) => ReactElement,\n  };\n  \n  export type {\n      // Hopefully you shouldn't have to use these, but they're here if you need!\n      // Top-level API:\n      State,\n      Parser,\n      Output,\n      ReactOutput,\n      HtmlOutput,\n  \n      // Most of the following types should be considered experimental and\n      // subject to change or change names. Again, they shouldn't be necessary,\n      // but if they are I'd love to hear how so I can better support them!\n  \n      // Individual Rule fields:\n      Capture,\n      MatchFunction,\n      ParseFunction,\n      NodeOutput,\n      ArrayNodeOutput,\n      ReactNodeOutput,\n  \n      // Single rules:\n      ParserRule,\n      ReactOutputRule,\n      HtmlOutputRule,\n  \n      // Sets of rules:\n      ParserRules,\n      OutputRules,\n      Rules,\n      ReactRules,\n      HtmlRules,\n  };\n  */\n\n\n  var SimpleMarkdown\n  /* : Exports */\n  = {\n    defaultRules: defaultRules,\n    parserFor: parserFor,\n    outputFor: outputFor,\n    inlineRegex: inlineRegex,\n    blockRegex: blockRegex,\n    anyScopeRegex: anyScopeRegex,\n    parseInline: parseInline,\n    parseBlock: parseBlock,\n    // default wrappers:\n    markdownToReact: markdownToReact,\n    markdownToHtml: markdownToHtml,\n    ReactMarkdown: ReactMarkdown,\n    defaultBlockParse: defaultBlockParse,\n    defaultInlineParse: defaultInlineParse,\n    defaultImplicitParse: defaultImplicitParse,\n    defaultReactOutput: defaultReactOutput,\n    defaultHtmlOutput: defaultHtmlOutput,\n    preprocess: preprocess,\n    sanitizeText: sanitizeText,\n    sanitizeUrl: sanitizeUrl,\n    unescapeUrl: unescapeUrl,\n    htmlTag: htmlTag,\n    reactElement: reactElement,\n    // deprecated:\n    defaultRawParse: defaultRawParse,\n    ruleOutput: ruleOutput,\n    reactFor: reactFor,\n    htmlFor: htmlFor,\n    defaultParse: function defaultParse() {\n      if (typeof console !== 'undefined') {\n        console.warn('defaultParse is deprecated, please use `defaultImplicitParse`');\n      }\n\n      return defaultImplicitParse.apply(null,\n      /** @type {any} */\n      arguments);\n    },\n    defaultOutput: function defaultOutput() {\n      if (typeof console !== 'undefined') {\n        console.warn('defaultOutput is deprecated, please use `defaultReactOutput`');\n      }\n\n      return defaultReactOutput.apply(null,\n      /** @type {any} */\n      arguments);\n    }\n  };\n  return SimpleMarkdown;\n});","map":{"version":3,"sources":["/home/joseph/projects/perses/node_modules/simple-markdown/simple-markdown.js"],"names":["global","factory","exports","module","define","amd","self","SimpleMarkdown","CR_NEWLINE_R","TAB_R","FORMFEED_R","preprocess","source","replace","populateInitialState","givenState","defaultState","state","prop","Object","prototype","hasOwnProperty","call","parserFor","rules","ruleList","keys","filter","type","rule","match","order","isFinite","console","warn","String","sort","typeA","typeB","ruleA","ruleB","orderA","orderB","secondaryOrderA","quality","secondaryOrderB","latestState","nestedParse","result","ruleType","capture","NaN","i","currRuleType","currRule","currOrder","prevCaptureStr","prevCapture","currCapture","currQuality","Error","length","index","parsed","parse","Array","isArray","push","apply","substring","outerParse","inline","disableAutoBlockNewlines","inlineRegex","regex","exec","blockRegex","anyScopeRegex","TYPE_SYMBOL","Symbol","for","reactElement","key","props","element","$$typeof","undefined","ref","_owner","htmlTag","tagName","content","attributes","isClosed","attributeString","attr","attribute","sanitizeText","unclosedTag","EMPTY_PROPS","sanitizeUrl","url","prot","decodeURIComponent","toLowerCase","indexOf","e","SANITIZE_TEXT_R","SANITIZE_TEXT_CODES","text","chr","UNESCAPE_URL_R","unescapeUrl","rawUrlString","parseInline","isCurrentlyInline","parseBlock","parseCaptureInline","ignoreCapture","LIST_BULLET","LIST_ITEM_PREFIX","LIST_ITEM_PREFIX_R","RegExp","LIST_ITEM_R","BLOCK_END_R","INLINE_CODE_ESCAPE_BACKTICKS_R","LIST_BLOCK_END_R","LIST_ITEM_END_R","LIST_R","LIST_LOOKBEHIND_R","TABLES","TABLE_ROW_SEPARATOR_TRIM","TABLE_CELL_END_TRIM","TABLE_RIGHT_ALIGN","TABLE_CENTER_ALIGN","TABLE_LEFT_ALIGN","parseTableAlignCapture","alignCapture","test","parseTableAlign","trimEndSeparators","alignText","trim","split","map","parseTableRow","prevInTable","inTable","tableRow","cells","forEach","node","parseTableCells","rowsText","rowText","parseTable","header","align","parseNpTable","TABLE_REGEX","NPTABLE_REGEX","LINK_INSIDE","LINK_HREF_AND_TITLE","AUTOLINK_MAILTO_CHECK_R","parseRef","refNode","_defs","def","target","title","_refs","defaultRules","react","arr","output","oldKey","html","heading","level","children","nptable","lheading","hr","codeBlock","lang","className","class","fence","blockQuote","list","isStartOfLineCapture","isListBlock","_list","bullet","ordered","start","items","lastItemWasAParagraph","itemContent","item","prefixCapture","space","spaceRegex","isLastItem","containsBlocks","thisItemIsAParagraph","oldStateInline","oldStateList","adjustedContent","ListWrapper","listItems","join","listTag","table","getStyle","colIndex","textAlign","headers","style","scope","rows","row","r","c","cols","thead","tbody","newline","paragraph","escape","tableSeparator","autolink","mailto","address","link","href","image","alt","src","reflink","refimage","em","strong","u","del","inlineCode","br","ruleOutput","property","nestedRuleOutput","ast","outputFunc","reactFor","nestedOutput","lastResult","nodeOut","htmlFor","outputFor","arrayRule","arrayRuleCheck","arrayRuleOutput","outerOutput","defaultRawParse","defaultBlockParse","defaultInlineParse","defaultImplicitParse","isBlock","defaultReactOutput","defaultHtmlOutput","markdownToReact","markdownToHtml","ReactMarkdown","divProps","defaultParse","arguments","defaultOutput"],"mappings":"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","sourcesContent":["(function (global, factory) {\ntypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\ntypeof define === 'function' && define.amd ? define(factory) :\n(global = global || self, global.SimpleMarkdown = factory());\n}(this, (function () { 'use strict';\n\n/* @flow */\n/* @ts-check */\n\n/**\n * Simple-Markdown\n * ===============\n *\n * Simple-Markdown's primary goal is to be easy to adapt. It aims\n * to be compliant with John Gruber's [Markdown Syntax page][1],\n * but compatiblity with other markdown implementations' edge-cases\n * will be sacrificed where it conflicts with simplicity or\n * extensibility.\n *\n * If your goal is to simply embed a standard markdown implementation\n * in your website, simple-markdown is probably not the best library\n * for you (although it should work). But if you have struggled to\n * customize an existing library to meet your needs, simple-markdown\n * might be able to help.\n *\n * Many of the regexes and original logic has been adapted from\n * the wonderful [marked.js](https://github.com/chjj/marked)\n *\n * LICENSE (MIT):\n * New code copyright (c) 2014-2019 Khan Academy & Aria Buckles.\n *\n * Portions adapted from marked.js copyright (c) 2011-2014\n * Christopher Jeffrey (https://github.com/chjj/).\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n// Typescript language & simple-markdown.d.ts references:\n/// <reference lib=\"ES2018\" />\n/// <reference path=\"../simple-markdown.d.ts\" />\n\n/*::\n// Flow Type Definitions:\n\ntype Capture =\n    Array<string> & {index: number} |\n    Array<string> & {index?: number};\n\ntype Attr = string | number | boolean | null | void;\n\ntype SingleASTNode = {\n    type: string,\n    [string]: any,\n};\n\ntype UnTypedASTNode = {\n    [string]: any\n};\n\ntype ASTNode = SingleASTNode | Array<SingleASTNode>;\n\ntype State = {\n    key?: string | number | void,\n    inline?: ?boolean,\n    [string]: any,\n};\n\ntype ReactElement = React$Element<any>;\ntype ReactElements = React$Node;\n\ntype MatchFunction = { regex?: RegExp } & (\n    source: string,\n    state: State,\n    prevCapture: string\n) => ?Capture;\n\ntype Parser = (\n    source: string,\n    state?: ?State\n) => Array<SingleASTNode>;\n\ntype ParseFunction = (\n    capture: Capture,\n    nestedParse: Parser,\n    state: State,\n) => (UnTypedASTNode | ASTNode);\n\ntype SingleNodeParseFunction = (\n    capture: Capture,\n    nestedParse: Parser,\n    state: State,\n) => UnTypedASTNode;\n\ntype Output<Result> = (\n    node: ASTNode,\n    state?: ?State\n) => Result;\n\ntype NodeOutput<Result> = (\n    node: SingleASTNode,\n    nestedOutput: Output<Result>,\n    state: State\n) => Result;\n\ntype ArrayNodeOutput<Result> = (\n    node: Array<SingleASTNode>,\n    nestedOutput: Output<Result>,\n    state: State\n) => Result;\n\ntype ReactOutput = Output<ReactElements>;\ntype ReactNodeOutput = NodeOutput<ReactElements>;\ntype HtmlOutput = Output<string>;\ntype HtmlNodeOutput = NodeOutput<string>;\n\ntype ParserRule = {\n    +order: number,\n    +match: MatchFunction,\n    +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n    +parse: ParseFunction,\n};\n\ntype SingleNodeParserRule = {\n    +order: number,\n    +match: MatchFunction,\n    +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n    +parse: SingleNodeParseFunction,\n};\n\ntype ReactOutputRule = {\n    // we allow null because some rules are never output results, and that's\n    // legal as long as no parsers return an AST node matching that rule.\n    // We don't use ? because this makes it be explicitly defined as either\n    // a valid function or null, so it can't be forgotten.\n    +react: ReactNodeOutput | null,\n};\n\ntype HtmlOutputRule = {\n    +html: HtmlNodeOutput | null,\n};\n\ntype ArrayRule = {\n    +react?: ArrayNodeOutput<ReactElements>,\n    +html?: ArrayNodeOutput<string>,\n    +[string]: ArrayNodeOutput<any>,\n};\n\ntype ParserRules = {\n    +Array?: ArrayRule,\n    +[type: string]: ParserRule,\n};\n\ntype OutputRules<Rule> = {\n    +Array?: ArrayRule,\n    +[type: string]: Rule\n};\ntype Rules<OutputRule> = {\n    +Array?: ArrayRule,\n    +[type: string]: ParserRule & OutputRule,\n};\ntype ReactRules = {\n    +Array?: {\n        +react: ArrayNodeOutput<ReactElements>,\n    },\n    +[type: string]: ParserRule & ReactOutputRule,\n};\ntype HtmlRules = {\n    +Array?: {\n        +html: ArrayNodeOutput<string>,\n    },\n    +[type: string]: ParserRule & HtmlOutputRule,\n};\n\n// We want to clarify our defaultRules types a little bit more so clients can\n// reuse defaultRules built-ins. So we make some stronger guarantess when\n// we can:\ntype NonNullReactOutputRule = {\n    +react: ReactNodeOutput,\n};\ntype ElementReactOutputRule = {\n    +react: NodeOutput<ReactElement>,\n};\ntype TextReactOutputRule = {\n    +react: NodeOutput<string>,\n};\ntype NonNullHtmlOutputRule = {\n    +html: HtmlNodeOutput,\n};\n\ntype DefaultInRule = SingleNodeParserRule & ReactOutputRule & HtmlOutputRule;\ntype TextInOutRule = SingleNodeParserRule & TextReactOutputRule & NonNullHtmlOutputRule;\ntype LenientInOutRule = SingleNodeParserRule & NonNullReactOutputRule & NonNullHtmlOutputRule;\ntype DefaultInOutRule = SingleNodeParserRule & ElementReactOutputRule & NonNullHtmlOutputRule;\n\ntype DefaultRules = {\n    +Array: {\n        +react: ArrayNodeOutput<ReactElements>,\n        +html: ArrayNodeOutput<string>\n    },\n    +heading: DefaultInOutRule,\n    +nptable: DefaultInRule,\n    +lheading: DefaultInRule,\n    +hr: DefaultInOutRule,\n    +codeBlock: DefaultInOutRule,\n    +fence: DefaultInRule,\n    +blockQuote: DefaultInOutRule,\n    +list: DefaultInOutRule,\n    +def: LenientInOutRule,\n    +table: DefaultInOutRule,\n    +tableSeparator: DefaultInRule,\n    +newline: TextInOutRule,\n    +paragraph: DefaultInOutRule,\n    +escape: DefaultInRule,\n    +autolink: DefaultInRule,\n    +mailto: DefaultInRule,\n    +url: DefaultInRule,\n    +link: DefaultInOutRule,\n    +image: DefaultInOutRule,\n    +reflink: DefaultInRule,\n    +refimage: DefaultInRule,\n    +em: DefaultInOutRule,\n    +strong: DefaultInOutRule,\n    +u: DefaultInOutRule,\n    +del: DefaultInOutRule,\n    +inlineCode: DefaultInOutRule,\n    +br: DefaultInOutRule,\n    +text: TextInOutRule,\n};\n\ntype RefNode = {\n    type: string,\n    content?: ASTNode,\n    target?: string,\n    title?: string,\n    alt?: string,\n};\n\n// End Flow Definitions\n*/\n\nvar CR_NEWLINE_R = /\\r\\n?/g;\nvar TAB_R = /\\t/g;\nvar FORMFEED_R = /\\f/g;\n\n/**\n * Turn various whitespace into easy-to-process whitespace\n * @param {string} source\n * @returns {string}\n */\nvar preprocess = function(source /* : string */) {\n    return source.replace(CR_NEWLINE_R, '\\n')\n            .replace(FORMFEED_R, '')\n            .replace(TAB_R, '    ');\n};\n\n/**\n * @param {SimpleMarkdown.OptionalState} givenState\n * @param {SimpleMarkdown.OptionalState} defaultState\n * @returns {SimpleMarkdown.State}\n */\nvar populateInitialState = function(\n    givenState /* : ?State */,\n    defaultState /* : ?State */\n) /* : State */{\n    var state /* : State */ = givenState || {};\n    if (defaultState != null) {\n        for (var prop in defaultState) {\n            if (Object.prototype.hasOwnProperty.call(defaultState, prop)) {\n                state[prop] = defaultState[prop];\n            }\n        }\n    }\n    return state;\n};\n\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @param {SimpleMarkdown.ParserRules} rules\n *     an object containing\n *     rule type -> {match, order, parse} objects\n *     (lower order is higher precedence)\n * @param {SimpleMarkdown.OptionalState} [defaultState]\n *\n * @returns {SimpleMarkdown.Parser}\n *     The resulting parse function, with the following parameters:\n *     @source: the input source string to be parsed\n *     @state: an optional object to be threaded through parse\n *         calls. Allows clients to add stateful operations to\n *         parsing, such as keeping track of how many levels deep\n *         some nesting is. For an example use-case, see passage-ref\n *         parsing in src/widgets/passage/passage-markdown.jsx\n */\nvar parserFor = function(rules /*: ParserRules */, defaultState /*: ?State */) {\n    // Sorts rules in order of increasing order, then\n    // ascending rule name in case of ties.\n    var ruleList = Object.keys(rules).filter(function(type) {\n        var rule = rules[type];\n        if (rule == null || rule.match == null) {\n            return false;\n        }\n        var order = rule.order;\n        if ((typeof order !== 'number' || !isFinite(order)) &&\n                typeof console !== 'undefined') {\n            console.warn(\n                \"simple-markdown: Invalid order for rule `\" + type + \"`: \" +\n                String(order)\n            );\n        }\n        return true;\n    });\n\n    ruleList.sort(function(typeA, typeB) {\n        var ruleA /* : ParserRule */ = /** @type {SimpleMarkdown.ParserRule} */ (rules[typeA] /*:: :any */);\n        var ruleB /* : ParserRule */ = /** @type {SimpleMarkdown.ParserRule} */ (rules[typeB] /*:: :any */);\n        var orderA = ruleA.order;\n        var orderB = ruleB.order;\n\n        // First sort based on increasing order\n        if (orderA !== orderB) {\n            return orderA - orderB;\n        }\n\n        var secondaryOrderA = ruleA.quality ? 0 : 1;\n        var secondaryOrderB = ruleB.quality ? 0 : 1;\n\n        if (secondaryOrderA !== secondaryOrderB) {\n            return secondaryOrderA - secondaryOrderB;\n\n        // Then based on increasing unicode lexicographic ordering\n        } else if (typeA < typeB) {\n            return -1;\n        } else if (typeA > typeB) {\n            return 1;\n\n        } else {\n            // Rules should never have the same name,\n            // but this is provided for completeness.\n            return 0;\n        }\n    });\n\n    /** @type {SimpleMarkdown.State} */\n    var latestState;\n    /** @type {SimpleMarkdown.Parser} */\n    var nestedParse = function(source /* : string */, state /* : ?State */) {\n        /** @type Array<SimpleMarkdown.SingleASTNode> */\n        var result = [];\n        state = state || latestState;\n        latestState = state;\n        while (source) {\n            // store the best match, it's rule, and quality:\n            var ruleType = null;\n            var rule = null;\n            var capture = null;\n            var quality = NaN;\n\n            // loop control variables:\n            var i = 0;\n            var currRuleType = ruleList[0];\n            var currRule /* : ParserRule */ = /** @type {SimpleMarkdown.ParserRule} */ ( rules[currRuleType] /*:: :any */ );\n\n            do {\n                var currOrder = currRule.order;\n                var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n                var currCapture = currRule.match(source, state, prevCaptureStr);\n\n                if (currCapture) {\n                    var currQuality = currRule.quality ? currRule.quality(\n                        currCapture,\n                        state,\n                        prevCaptureStr\n                    ) : 0;\n                    // This should always be true the first time because\n                    // the initial quality is NaN (that's why there's the\n                    // condition negation).\n                    if (!(currQuality <= quality)) {\n                        ruleType = currRuleType;\n                        rule = currRule;\n                        capture = currCapture;\n                        quality = currQuality;\n                    }\n                }\n\n                // Move on to the next item.\n                // Note that this makes `currRule` be the next item\n                i++;\n                currRuleType = ruleList[i];\n                currRule = /*::((*/ /** @type {SimpleMarkdown.ParserRule} */ (rules[currRuleType]) /*:: : any) : ParserRule)*/;\n\n            } while (\n                // keep looping while we're still within the ruleList\n                currRule && (\n                    // if we don't have a match yet, continue\n                    !capture || (\n                        // or if we have a match, but the next rule is\n                        // at the same order, and has a quality measurement\n                        // functions, then this rule must have a quality\n                        // measurement function (since they are sorted before\n                        // those without), and we need to check if there is\n                        // a better quality match\n                        currRule.order === currOrder &&\n                        currRule.quality\n                    )\n                )\n            );\n\n            // TODO(aria): Write tests for these\n            if (rule == null || capture == null /*:: || ruleType == null */) {\n                throw new Error(\n                    \"Could not find a matching rule for the below \" +\n                    \"content. The rule with highest `order` should \" +\n                    \"always match content provided to it. Check \" +\n                    \"the definition of `match` for '\" +\n                    ruleList[ruleList.length - 1] +\n                    \"'. It seems to not match the following source:\\n\" +\n                    source\n                );\n            }\n            if (capture.index) { // If present and non-zero, i.e. a non-^ regexp result:\n                throw new Error(\n                    \"`match` must return a capture starting at index 0 \" +\n                    \"(the current parse index). Did you forget a ^ at the \" +\n                    \"start of the RegExp?\"\n                );\n            }\n\n            var parsed = rule.parse(capture, nestedParse, state);\n            // We maintain the same object here so that rules can\n            // store references to the objects they return and\n            // modify them later. (oops sorry! but this adds a lot\n            // of power--see reflinks.)\n            if (Array.isArray(parsed)) {\n                Array.prototype.push.apply(result, parsed);\n            } else {\n                // We also let rules override the default type of\n                // their parsed node if they would like to, so that\n                // there can be a single output function for all links,\n                // even if there are several rules to parse them.\n                if (parsed.type == null) {\n                    parsed.type = ruleType;\n                }\n                result.push(/** @type {SimpleMarkdown.SingleASTNode} */ (parsed));\n            }\n\n            state.prevCapture = capture;\n            source = source.substring(state.prevCapture[0].length);\n        }\n        return result;\n    };\n\n    /** @type {SimpleMarkdown.Parser} */\n    var outerParse = function(source /* : string */, state /* : ?State */) {\n        latestState = populateInitialState(state, defaultState);\n        if (!latestState.inline && !latestState.disableAutoBlockNewlines) {\n            source = source + \"\\n\\n\";\n        }\n        // We store the previous capture so that match functions can\n        // use some limited amount of lookbehind. Lists use this to\n        // ensure they don't match arbitrary '- ' or '* ' in inline\n        // text (see the list rule for more information). This stores\n        // the full regex capture object, if there is one.\n        latestState.prevCapture = null;\n        return nestedParse(preprocess(source), latestState);\n    };\n    return outerParse;\n};\n\n// Creates a match function for an inline scoped element from a regex\n/** @type {(regex: RegExp) => SimpleMarkdown.MatchFunction} */\nvar inlineRegex = function(regex /* : RegExp */) {\n    /** @type {SimpleMarkdown.MatchFunction} */\n    var match /* : MatchFunction */ = function(source, state) {\n        if (state.inline) {\n            return regex.exec(source);\n        } else {\n            return null;\n        }\n    };\n    match.regex = regex;\n    return match;\n};\n\n// Creates a match function for a block scoped element from a regex\n/** @type {(regex: RegExp) => SimpleMarkdown.MatchFunction} */\nvar blockRegex = function(regex /* : RegExp */) {\n    /** @type {SimpleMarkdown.MatchFunction} */\n    var match /* : MatchFunction */ = function(source, state) {\n        if (state.inline) {\n            return null;\n        } else {\n            return regex.exec(source);\n        }\n    };\n    match.regex = regex;\n    return match;\n};\n\n// Creates a match function from a regex, ignoring block/inline scope\n/** @type {(regex: RegExp) => SimpleMarkdown.MatchFunction} */\nvar anyScopeRegex = function(regex /* : RegExp */) {\n    /** @type {SimpleMarkdown.MatchFunction} */\n    var match /* : MatchFunction */ = function(source, state) {\n        return regex.exec(source);\n    };\n    match.regex = regex;\n    return match;\n};\n\nvar TYPE_SYMBOL =\n    (typeof Symbol === 'function' && Symbol.for &&\n     Symbol.for('react.element')) ||\n    0xeac7;\n\n/**\n * @param {string} type\n * @param {string | number | null | undefined} key\n * @param {Object<string, any>} props\n * @returns {SimpleMarkdown.ReactElement}\n */\nvar reactElement = function(\n    type /* : string */,\n    key /* : string | number | null | void */,\n    props /* : { [string]: any } */\n) /* : ReactElement */ {\n    var element /* : ReactElement */ = /** @type {SimpleMarkdown.ReactElement} */ ({\n        $$typeof: TYPE_SYMBOL,\n        type: type,\n        key: key == null ? undefined : key,\n        ref: null,\n        props: props,\n        _owner: null\n    } /* : any */);\n    return element;\n};\n\n/** Returns a closed HTML tag.\n * @param {string} tagName - Name of HTML tag (eg. \"em\" or \"a\")\n * @param {string} content - Inner content of tag\n * @param {{ [attr: string]: SimpleMarkdown.Attr }} [attributes] - Optional extra attributes of tag as an object of key-value pairs\n *   eg. { \"href\": \"http://google.com\" }. Falsey attributes are filtered out.\n * @param {boolean} [isClosed] - boolean that controls whether tag is closed or not (eg. img tags).\n *   defaults to true\n */\nvar htmlTag = function(\n    tagName /* : string */,\n    content /* : string */,\n    attributes /* : ?{[any]: ?Attr} */,\n    isClosed /* : ?boolean */\n) {\n    attributes = attributes || {};\n    isClosed = typeof isClosed !== 'undefined' ? isClosed : true;\n\n    var attributeString = \"\";\n    for (var attr in attributes) {\n        var attribute = attributes[attr];\n        // Removes falsey attributes\n        if (Object.prototype.hasOwnProperty.call(attributes, attr) &&\n                attribute) {\n            attributeString += \" \" +\n                sanitizeText(attr) + '=\"' +\n                sanitizeText(attribute) + '\"';\n        }\n    }\n\n    var unclosedTag = \"<\" + tagName + attributeString + \">\";\n\n    if (isClosed) {\n        return unclosedTag + content + \"</\" + tagName + \">\";\n    } else {\n        return unclosedTag;\n    }\n};\n\nvar EMPTY_PROPS = {};\n\n/**\n * @param {string | null | undefined} url - url to sanitize\n * @returns {string | null} - url if safe, or null if a safe url could not be made\n */\nvar sanitizeUrl = function(url /* : ?string */) {\n    if (url == null) {\n        return null;\n    }\n    try {\n        var prot = decodeURIComponent(url)\n            .replace(/[^A-Za-z0-9/:]/g, '')\n            .toLowerCase();\n        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n            return null;\n        }\n    } catch (e) {\n        // decodeURIComponent sometimes throws a URIError\n        // See `decodeURIComponent('a%AFc');`\n        // http://stackoverflow.com/questions/9064536/javascript-decodeuricomponent-malformed-uri-exception\n        return null;\n    }\n    return url;\n};\n\nvar SANITIZE_TEXT_R = /[<>&\"']/g;\n/** @type {any} */\nvar SANITIZE_TEXT_CODES = {\n    '<': '&lt;',\n    '>': '&gt;',\n    '&': '&amp;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '/': '&#x2F;',\n    \"`\": '&#96;'\n};\n/**\n * @param {SimpleMarkdown.Attr} text\n * @returns {string}\n */\nvar sanitizeText = function(text /* : Attr */) {\n    return String(text).replace(SANITIZE_TEXT_R, function(chr) {\n        return SANITIZE_TEXT_CODES[chr];\n    });\n};\n\nvar UNESCAPE_URL_R = /\\\\([^0-9A-Za-z\\s])/g;\n\n/**\n * @param {string} rawUrlString\n * @returns {string}\n */\nvar unescapeUrl = function(rawUrlString /* : string */) {\n    return rawUrlString.replace(UNESCAPE_URL_R, \"$1\");\n};\n\n/**\n * Parse some content with the parser `parse`, with state.inline\n * set to true. Useful for block elements; not generally necessary\n * to be used by inline elements (where state.inline is already true.\n *\n * @param {SimpleMarkdown.Parser} parse\n * @param {string} content\n * @param {SimpleMarkdown.State} state\n * @returns {SimpleMarkdown.ASTNode}\n */\nvar parseInline = function(parse, content, state) {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = true;\n    var result = parse(content, state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\n/**\n * @param {SimpleMarkdown.Parser} parse\n * @param {string} content\n * @param {SimpleMarkdown.State} state\n * @returns {SimpleMarkdown.ASTNode}\n */\nvar parseBlock = function(parse, content, state) {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = false;\n    var result = parse(content + \"\\n\\n\", state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\n\n/**\n * @param {SimpleMarkdown.Capture} capture\n * @param {SimpleMarkdown.Parser} parse\n * @param {SimpleMarkdown.State} state\n * @returns {SimpleMarkdown.UnTypedASTNode}\n */\nvar parseCaptureInline = function(capture, parse, state) {\n    return {\n        content: parseInline(parse, capture[1], state)\n    };\n};\n/**\n * @returns {SimpleMarkdown.UnTypedASTNode}\n */\nvar ignoreCapture = function() { return {}; };\n\n// recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\nvar LIST_BULLET = \"(?:[*+-]|\\\\d+\\\\.)\";\n// recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\nvar LIST_ITEM_PREFIX = \"( *)(\" + LIST_BULLET + \") +\";\nvar LIST_ITEM_PREFIX_R = new RegExp(\"^\" + LIST_ITEM_PREFIX);\n// recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\nvar LIST_ITEM_R = new RegExp(\n    LIST_ITEM_PREFIX +\n    \"[^\\\\n]*(?:\\\\n\" +\n    \"(?!\\\\1\" + LIST_BULLET + \" )[^\\\\n]*)*(\\n|$)\",\n    \"gm\"\n);\nvar BLOCK_END_R = /\\n{2,}$/;\nvar INLINE_CODE_ESCAPE_BACKTICKS_R = /^ (?= *`)|(` *) $/g;\n// recognize the end of a paragraph block inside a list item:\n// two or more newlines at end end of the item\nvar LIST_BLOCK_END_R = BLOCK_END_R;\nvar LIST_ITEM_END_R = / *\\n+$/;\n// check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\nvar LIST_R = new RegExp(\n    \"^( *)(\" + LIST_BULLET + \") \" +\n    \"[\\\\s\\\\S]+?(?:\\n{2,}(?! )\" +\n    \"(?!\\\\1\" + LIST_BULLET + \" )\\\\n*\" +\n    // the \\\\s*$ here is so that we can parse the inside of nested\n    // lists, where our content might end before we receive two `\\n`s\n    \"|\\\\s*\\n*$)\"\n);\nvar LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/;\n\nvar TABLES = (function() {\n    var TABLE_ROW_SEPARATOR_TRIM = /^ *\\| *| *\\| *$/g;\n    var TABLE_CELL_END_TRIM = / *$/;\n    var TABLE_RIGHT_ALIGN = /^ *-+: *$/;\n    var TABLE_CENTER_ALIGN = /^ *:-+: *$/;\n    var TABLE_LEFT_ALIGN = /^ *:-+ *$/;\n\n    /**\n     * @param {string} alignCapture\n     * @returns {SimpleMarkdown.TableAlignment}\n     */\n    var parseTableAlignCapture = function(alignCapture) {\n        if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n            return \"right\";\n        } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n            return \"center\";\n        } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n            return \"left\";\n        } else {\n            return null;\n        }\n    };\n\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {Array<SimpleMarkdown.TableAlignment>}\n     */\n    var parseTableAlign = function(source, parse, state, trimEndSeparators) {\n        if (trimEndSeparators) {\n            source = source.replace(TABLE_ROW_SEPARATOR_TRIM, \"\");\n        }\n        var alignText = source.trim().split(\"|\");\n        return alignText.map(parseTableAlignCapture);\n    };\n\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.SingleASTNode[][]}\n     */\n    var parseTableRow = function(source, parse, state, trimEndSeparators) {\n        var prevInTable = state.inTable;\n        state.inTable = true;\n        var tableRow = parse(source.trim(), state);\n        state.inTable = prevInTable;\n\n        /** @type {SimpleMarkdown.SingleASTNode[][]} */\n        var cells = [[]];\n        tableRow.forEach(function(node, i) {\n            if (node.type === 'tableSeparator') {\n                // Filter out empty table separators at the start/end:\n                if (!trimEndSeparators || i !== 0 && i !== tableRow.length - 1) {\n                    // Split the current row:\n                    cells.push([]);\n                }\n            } else {\n                if (node.type === 'text' && (\n                    tableRow[i + 1] == null ||\n                    tableRow[i + 1].type === 'tableSeparator'\n                )) {\n                    node.content = node.content.replace(TABLE_CELL_END_TRIM, \"\");\n                }\n                cells[cells.length - 1].push(node);\n            }\n        });\n\n        return cells;\n    };\n\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.ASTNode[][]}\n     */\n    var parseTableCells = function(source, parse, state, trimEndSeparators) {\n        var rowsText = source.trim().split(\"\\n\");\n\n        return rowsText.map(function(rowText) {\n            return parseTableRow(rowText, parse, state, trimEndSeparators);\n        });\n    };\n\n    /**\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.SingleNodeParseFunction}\n     */\n    var parseTable = function(trimEndSeparators) {\n        /** @type {SimpleMarkdown.SingleNodeParseFunction} */\n        return function(capture, parse, state) {\n            state.inline = true;\n            var header = parseTableRow(capture[1], parse, state, trimEndSeparators);\n            var align = parseTableAlign(capture[2], parse, state, trimEndSeparators);\n            var cells = parseTableCells(capture[3], parse, state, trimEndSeparators);\n            state.inline = false;\n\n            return {\n                type: \"table\",\n                header: header,\n                align: align,\n                cells: cells\n            };\n        };\n    };\n\n    return {\n        parseTable: parseTable(true),\n        parseNpTable: parseTable(false),\n        TABLE_REGEX: /^ *(\\|.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/,\n        NPTABLE_REGEX: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/\n    };\n})();\n\nvar LINK_INSIDE = \"(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*\";\nvar LINK_HREF_AND_TITLE =\n        \"\\\\s*<?((?:\\\\([^)]*\\\\)|[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\";\nvar AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\n\n/**\n * @param {SimpleMarkdown.Capture} capture\n * @param {SimpleMarkdown.State} state\n * @param {SimpleMarkdown.RefNode} refNode\n * @returns {SimpleMarkdown.RefNode}\n */\nvar parseRef = function(capture, state, refNode /* : RefNode */) {\n    var ref = (capture[2] || capture[1])\n        .replace(/\\s+/g, ' ')\n        .toLowerCase();\n\n    // We store information about previously seen defs on\n    // state._defs (_ to deconflict with client-defined\n    // state). If the def for this reflink/refimage has\n    // already been seen, we can use its target/source\n    // and title here:\n    if (state._defs && state._defs[ref]) {\n        var def = state._defs[ref];\n        // `refNode` can be a link or an image. Both use\n        // target and title properties.\n        refNode.target = def.target;\n        refNode.title = def.title;\n    }\n\n    // In case we haven't seen our def yet (or if someone\n    // overwrites that def later on), we add this node\n    // to the list of ref nodes for that def. Then, when\n    // we find the def, we can modify this link/image AST\n    // node :).\n    // I'm sorry.\n    state._refs = state._refs || {};\n    state._refs[ref] = state._refs[ref] || [];\n    state._refs[ref].push(refNode);\n\n    return refNode;\n};\n\nvar currOrder = 0;\n/** @type {SimpleMarkdown.DefaultRules} */\nvar defaultRules /* : DefaultRules */ = {\n    Array: {\n        react: function(arr, output, state) {\n            var oldKey = state.key;\n            var result /* : Array<ReactElements> */ = [];\n\n            // map output over the ast, except group any text\n            // nodes together into a single string output.\n            for (var i = 0, key = 0; i < arr.length; i++, key++) {\n                // `key` is our numerical `state.key`, which we increment for\n                // every output node, but don't change for joined text nodes.\n                // (i, however, must change for joined text nodes)\n                state.key = '' + i;\n\n                var node = arr[i];\n                if (node.type === 'text') {\n                    node = { type: 'text', content: node.content };\n                    for (; i + 1 < arr.length && arr[i + 1].type === 'text'; i++) {\n                        node.content += arr[i + 1].content;\n                    }\n                }\n\n                result.push(output(node, state));\n            }\n\n            state.key = oldKey;\n            return result;\n        },\n        html: function(arr, output, state) {\n            var result = \"\";\n\n            // map output over the ast, except group any text\n            // nodes together into a single string output.\n            for (var i = 0; i < arr.length; i++) {\n\n                var node = arr[i];\n                if (node.type === 'text') {\n                    node = { type: 'text', content: node.content };\n                    for (; i + 1 < arr.length && arr[i + 1].type === 'text'; i++) {\n                        node.content += arr[i + 1].content;\n                    }\n                }\n\n                result += output(node, state);\n            }\n            return result;\n        }\n    },\n    heading: {\n        order: currOrder++,\n        match: blockRegex(/^ *(#{1,6})([^\\n]+?)#* *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                level: capture[1].length,\n                content: parseInline(parse, capture[2].trim(), state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'h' + node.level,\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"h\" + node.level, output(node.content, state));\n        }\n    },\n    nptable: {\n        order: currOrder++,\n        match: blockRegex(TABLES.NPTABLE_REGEX),\n        parse: TABLES.parseNpTable,\n        react: null,\n        html: null\n    },\n    lheading: {\n        order: currOrder++,\n        match: blockRegex(/^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"heading\",\n                level: capture[2] === '=' ? 1 : 2,\n                content: parseInline(parse, capture[1], state)\n            };\n        },\n        react: null,\n        html: null\n    },\n    hr: {\n        order: currOrder++,\n        match: blockRegex(/^( *[-*_]){3,} *(?:\\n *)+\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) {\n            return reactElement(\n                'hr',\n                state.key,\n                EMPTY_PROPS\n            );\n        },\n        html: function(node, output, state) {\n            return \"<hr>\";\n        }\n    },\n    codeBlock: {\n        order: currOrder++,\n        match: blockRegex(/^(?:    [^\\n]+\\n*)+(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            var content = capture[0]\n                .replace(/^    /gm, '')\n                .replace(/\\n+$/, '');\n            return {\n                lang: undefined,\n                content: content\n            };\n        },\n        react: function(node, output, state) {\n            var className = node.lang ?\n                \"markdown-code-\" + node.lang :\n                undefined;\n\n            return reactElement(\n                'pre',\n                state.key,\n                {\n                    children: reactElement(\n                        'code',\n                        null,\n                        {\n                            className: className,\n                            children: node.content\n                        }\n                    )\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var className = node.lang ?\n                \"markdown-code-\" + node.lang :\n                undefined;\n\n            var codeBlock = htmlTag(\"code\", sanitizeText(node.content), {\n                class: className\n            });\n            return htmlTag(\"pre\", codeBlock);\n        }\n    },\n    fence: {\n        order: currOrder++,\n        match: blockRegex(/^ *(`{3,}|~{3,}) *(?:(\\S+) *)?\\n([\\s\\S]+?)\\n?\\1 *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"codeBlock\",\n                lang: capture[2] || undefined,\n                content: capture[3]\n            };\n        },\n        react: null,\n        html: null\n    },\n    blockQuote: {\n        order: currOrder++,\n        match: blockRegex(/^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/),\n        parse: function(capture, parse, state) {\n            var content = capture[0].replace(/^ *> ?/gm, '');\n            return {\n                content: parse(content, state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'blockquote',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"blockquote\", output(node.content, state));\n        }\n    },\n    list: {\n        order: currOrder++,\n        match: function(source, state) {\n            // We only want to break into a list if we are at the start of a\n            // line. This is to avoid parsing \"hi * there\" with \"* there\"\n            // becoming a part of a list.\n            // You might wonder, \"but that's inline, so of course it wouldn't\n            // start a list?\". You would be correct! Except that some of our\n            // lists can be inline, because they might be inside another list,\n            // in which case we can parse with inline scope, but need to allow\n            // nested lists inside this inline scope.\n            var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n            var isStartOfLineCapture = LIST_LOOKBEHIND_R.exec(prevCaptureStr);\n            var isListBlock = state._list || !state.inline;\n\n            if (isStartOfLineCapture && isListBlock) {\n                source = isStartOfLineCapture[1] + source;\n                return LIST_R.exec(source);\n            } else {\n                return null;\n            }\n        },\n        parse: function(capture, parse, state) {\n            var bullet = capture[2];\n            var ordered = bullet.length > 1;\n            var start = ordered ? +bullet : undefined;\n            var items = /** @type {string[]} */ (\n                capture[0]\n                    .replace(LIST_BLOCK_END_R, \"\\n\")\n                    .match(LIST_ITEM_R)\n            );\n\n            // We know this will match here, because of how the regexes are\n            // defined\n            /*:: items = ((items : any) : Array<string>) */\n\n            var lastItemWasAParagraph = false;\n            var itemContent = items.map(function(/** @type {string} */ item, /** @type {number} */ i) {\n                // We need to see how far indented this item is:\n                var prefixCapture = LIST_ITEM_PREFIX_R.exec(item);\n                var space = prefixCapture ? prefixCapture[0].length : 0;\n                // And then we construct a regex to \"unindent\" the subsequent\n                // lines of the items by that amount:\n                var spaceRegex = new RegExp(\"^ {1,\" + space + \"}\", \"gm\");\n\n                // Before processing the item, we need a couple things\n                var content = item\n                         // remove indents on trailing lines:\n                        .replace(spaceRegex, '')\n                         // remove the bullet:\n                        .replace(LIST_ITEM_PREFIX_R, '');\n\n                // I'm not sur4 why this is necessary again?\n                /*:: items = ((items : any) : Array<string>) */\n\n                // Handling \"loose\" lists, like:\n                //\n                //  * this is wrapped in a paragraph\n                //\n                //  * as is this\n                //\n                //  * as is this\n                var isLastItem = (i === items.length - 1);\n                var containsBlocks = content.indexOf(\"\\n\\n\") !== -1;\n\n                // Any element in a list is a block if it contains multiple\n                // newlines. The last element in the list can also be a block\n                // if the previous item in the list was a block (this is\n                // because non-last items in the list can end with \\n\\n, but\n                // the last item can't, so we just \"inherit\" this property\n                // from our previous element).\n                var thisItemIsAParagraph = containsBlocks ||\n                        (isLastItem && lastItemWasAParagraph);\n                lastItemWasAParagraph = thisItemIsAParagraph;\n\n                // backup our state for restoration afterwards. We're going to\n                // want to set state._list to true, and state.inline depending\n                // on our list's looseness.\n                var oldStateInline = state.inline;\n                var oldStateList = state._list;\n                state._list = true;\n\n                // Parse inline if we're in a tight list, or block if we're in\n                // a loose list.\n                var adjustedContent;\n                if (thisItemIsAParagraph) {\n                    state.inline = false;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\\n\\n\");\n                } else {\n                    state.inline = true;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\");\n                }\n\n                var result = parse(adjustedContent, state);\n\n                // Restore our state before returning\n                state.inline = oldStateInline;\n                state._list = oldStateList;\n                return result;\n            });\n\n            return {\n                ordered: ordered,\n                start: start,\n                items: itemContent\n            };\n        },\n        react: function(node, output, state) {\n            var ListWrapper = node.ordered ? \"ol\" : \"ul\";\n\n            return reactElement(\n                ListWrapper,\n                state.key,\n                {\n                    start: node.start,\n                    children: node.items.map(function(\n                        /** @type {SimpleMarkdown.ASTNode} */ item,\n                        /** @type {number} */ i\n                    ) {\n                        return reactElement(\n                            'li',\n                            '' + i,\n                            {\n                                children: output(item, state)\n                            }\n                        );\n                    })\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var listItems = node.items.map(function(/** @type {SimpleMarkdown.ASTNode} */ item) {\n                return htmlTag(\"li\", output(item, state));\n            }).join(\"\");\n\n            var listTag = node.ordered ? \"ol\" : \"ul\";\n            var attributes = {\n                start: node.start\n            };\n            return htmlTag(listTag, listItems, attributes);\n        }\n    },\n    def: {\n        order: currOrder++,\n        // TODO(aria): This will match without a blank line before the next\n        // block element, which is inconsistent with most of the rest of\n        // simple-markdown.\n        match: blockRegex(\n            /^ *\\[([^\\]]+)\\]: *<?([^\\s>]*)>?(?: +[\"(]([^\\n]+)[\")])? *\\n(?: *\\n)*/\n        ),\n        parse: function(capture, parse, state) {\n            var def = capture[1]\n                .replace(/\\s+/g, ' ')\n                .toLowerCase();\n            var target = capture[2];\n            var title = capture[3];\n\n            // Look for previous links/images using this def\n            // If any links/images using this def have already been declared,\n            // they will have added themselves to the state._refs[def] list\n            // (_ to deconflict with client-defined state). We look through\n            // that list of reflinks for this def, and modify those AST nodes\n            // with our newly found information now.\n            // Sorry :(.\n            if (state._refs && state._refs[def]) {\n                // `refNode` can be a link or an image\n                state._refs[def].forEach(function(/** @type {SimpleMarkdown.RefNode} */ refNode) {\n                    refNode.target = target;\n                    refNode.title = title;\n                });\n            }\n\n            // Add this def to our map of defs for any future links/images\n            // In case we haven't found any or all of the refs referring to\n            // this def yet, we add our def to the table of known defs, so\n            // that future reflinks can modify themselves appropriately with\n            // this information.\n            state._defs = state._defs || {};\n            state._defs[def] = {\n                target: target,\n                title: title,\n            };\n\n            // return the relevant parsed information\n            // for debugging only.\n            return {\n                def: def,\n                target: target,\n                title: title,\n            };\n        },\n        react: function() { return null; },\n        html: function() { return \"\"; }\n    },\n    table: {\n        order: currOrder++,\n        match: blockRegex(TABLES.TABLE_REGEX),\n        parse: TABLES.parseTable,\n        react: function(node, output, state) {\n            /**\n             * @param {number} colIndex\n             * @returns {{ [attr: string]: SimpleMarkdown.Attr }}\n             */\n            var getStyle = function(colIndex) {\n                return node.align[colIndex] == null ? {} : {\n                    textAlign: node.align[colIndex]\n                };\n            };\n\n            var headers = node.header.map(function(\n                /** @type {SimpleMarkdown.ASTNode} */ content,\n                /** @type {number} */ i\n            ) {\n                return reactElement(\n                    'th',\n                    '' + i,\n                    {\n                        style: getStyle(i),\n                        scope: 'col',\n                        children: output(content, state)\n                    }\n                );\n            });\n\n            var rows = node.cells.map(function(\n                    /** @type {SimpleMarkdown.ASTNode[]} */ row,\n                    /** @type {number} */ r\n            ) {\n                return reactElement(\n                    'tr',\n                    '' + r,\n                    {\n                        children: row.map(function(\n                            /** @type {SimpleMarkdown.ASTNode} */ content,\n                            /** @type {number} */ c\n                        ) {\n                            return reactElement(\n                                'td',\n                                '' + c,\n                                {\n                                    style: getStyle(c),\n                                    children: output(content, state)\n                                }\n                            );\n                        })\n                    }\n                );\n            });\n\n            return reactElement(\n                'table',\n                state.key,\n                {\n                    children: [reactElement(\n                        'thead',\n                        'thead',\n                        {\n                            children: reactElement(\n                                'tr',\n                                null,\n                                {\n                                    children: headers\n                                }\n                            )\n                        }\n                    ), reactElement(\n                        'tbody',\n                        'tbody',\n                        {\n                            children: rows\n                        }\n                    )]\n                }\n            );\n        },\n        html: function(node, output, state) {\n            /**\n             * @param {number} colIndex\n             * @returns {string}\n             */\n            var getStyle = function(colIndex) {\n                return node.align[colIndex] == null ? \"\" :\n                    \"text-align:\" + node.align[colIndex] + \";\";\n            };\n\n            var headers = node.header.map(function(\n                /** @type {SimpleMarkdown.ASTNode} */ content,\n                /** @type {number} */ i\n            ) {\n                return htmlTag(\"th\", output(content, state),\n                    { style: getStyle(i), scope: \"col\" });\n            }).join(\"\");\n\n            var rows = node.cells.map(function(/** @type {SimpleMarkdown.ASTNode[]} */ row) {\n                var cols = row.map(function(\n                    /** @type {SimpleMarkdown.ASTNode} */ content,\n                    /** @type {number} */ c\n                ) {\n                    return htmlTag(\"td\", output(content, state),\n                        { style: getStyle(c) });\n                }).join(\"\");\n\n                return htmlTag(\"tr\", cols);\n            }).join(\"\");\n\n            var thead = htmlTag(\"thead\", htmlTag(\"tr\", headers));\n            var tbody = htmlTag(\"tbody\", rows);\n\n            return htmlTag(\"table\", thead + tbody);\n        }\n    },\n    newline: {\n        order: currOrder++,\n        match: blockRegex(/^(?:\\n *)*\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) { return \"\\n\"; },\n        html: function(node, output, state) { return \"\\n\"; }\n    },\n    paragraph: {\n        order: currOrder++,\n        match: blockRegex(/^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/),\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'div',\n                state.key,\n                {\n                    className: 'paragraph',\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                class: 'paragraph'\n            };\n            return htmlTag(\"div\", output(node.content, state), attributes);\n        }\n    },\n    escape: {\n        order: currOrder++,\n        // We don't allow escaping numbers, letters, or spaces here so that\n        // backslashes used in plain text still get rendered. But allowing\n        // escaping anything else provides a very flexible escape mechanism,\n        // regardless of how this grammar is extended.\n        match: inlineRegex(/^\\\\([^0-9A-Za-z\\s])/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"text\",\n                content: capture[1]\n            };\n        },\n        react: null,\n        html: null\n    },\n    tableSeparator: {\n        order: currOrder++,\n        match: function(source, state) {\n            if (!state.inTable) {\n                return null;\n            }\n            return /^ *\\| */.exec(source);\n        },\n        parse: function() {\n            return { type: 'tableSeparator' };\n        },\n        // These shouldn't be reached, but in case they are, be reasonable:\n        react: function() { return ' | '; },\n        html: function() { return ' &vert; '; },\n    },\n    autolink: {\n        order: currOrder++,\n        match: inlineRegex(/^<([^: >]+:\\/[^ >]+)>/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: capture[1]\n                }],\n                target: capture[1]\n            };\n        },\n        react: null,\n        html: null\n    },\n    mailto: {\n        order: currOrder++,\n        match: inlineRegex(/^<([^ >]+@[^ >]+)>/),\n        parse: function(capture, parse, state) {\n            var address = capture[1];\n            var target = capture[1];\n\n            // Check for a `mailto:` already existing in the link:\n            if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n                target = \"mailto:\" + target;\n            }\n\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: address\n                }],\n                target: target\n            };\n        },\n        react: null,\n        html: null\n    },\n    url: {\n        order: currOrder++,\n        match: inlineRegex(/^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: capture[1]\n                }],\n                target: capture[1],\n                title: undefined\n            };\n        },\n        react: null,\n        html: null\n    },\n    link: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\"\n        )),\n        parse: function(capture, parse, state) {\n            var link ={\n                content: parse(capture[1], state),\n                target: unescapeUrl(capture[2]),\n                title: capture[3]\n            };\n            return link;\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'a',\n                state.key,\n                {\n                    href: sanitizeUrl(node.target),\n                    title: node.title,\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                href: sanitizeUrl(node.target),\n                title: node.title\n            };\n\n            return htmlTag(\"a\", output(node.content, state), attributes);\n        }\n    },\n    image: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\"\n        )),\n        parse: function(capture, parse, state) {\n            var image = {\n                alt: capture[1],\n                target: unescapeUrl(capture[2]),\n                title: capture[3]\n            };\n            return image;\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'img',\n                state.key,\n                {\n                    src: sanitizeUrl(node.target),\n                    alt: node.alt,\n                    title: node.title\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                src: sanitizeUrl(node.target),\n                alt: node.alt,\n                title: node.title\n            };\n\n            return htmlTag(\"img\", \"\", attributes, false);\n        }\n    },\n    reflink: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            // The first [part] of the link\n            \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\" +\n            // The [ref] target of the link\n            \"\\\\s*\\\\[([^\\\\]]*)\\\\]\"\n        )),\n        parse: function(capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"link\",\n                content: parse(capture[1], state)\n            });\n        },\n        react: null,\n        html: null\n    },\n    refimage: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            // The first [part] of the link\n            \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\" +\n            // The [ref] target of the link\n            \"\\\\s*\\\\[([^\\\\]]*)\\\\]\"\n        )),\n        parse: function(capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"image\",\n                alt: capture[1]\n            });\n        },\n        react: null,\n        html: null\n    },\n    em: {\n        order: currOrder /* same as strong/u */,\n        match: inlineRegex(\n            new RegExp(\n                // only match _s surrounding words.\n                \"^\\\\b_\" +\n                \"((?:__|\\\\\\\\[\\\\s\\\\S]|[^\\\\\\\\_])+?)_\" +\n                \"\\\\b\" +\n                // Or match *s:\n                \"|\" +\n                // Only match *s that are followed by a non-space:\n                \"^\\\\*(?=\\\\S)(\" +\n                // Match at least one of:\n                \"(?:\" +\n                  //  - `**`: so that bolds inside italics don't close the\n                  //          italics\n                  \"\\\\*\\\\*|\" +\n                  //  - escape sequence: so escaped *s don't close us\n                  \"\\\\\\\\[\\\\s\\\\S]|\" +\n                  //  - whitespace: followed by a non-* (we don't\n                  //          want ' *' to close an italics--it might\n                  //          start a list)\n                  \"\\\\s+(?:\\\\\\\\[\\\\s\\\\S]|[^\\\\s\\\\*\\\\\\\\]|\\\\*\\\\*)|\" +\n                  //  - non-whitespace, non-*, non-backslash characters\n                  \"[^\\\\s\\\\*\\\\\\\\]\" +\n                \")+?\" +\n                // followed by a non-space, non-* then *\n                \")\\\\*(?!\\\\*)\"\n            )\n        ),\n        quality: function(capture) {\n            // precedence by length, `em` wins ties:\n            return capture[0].length + 0.2;\n        },\n        parse: function(capture, parse, state) {\n            return {\n                content: parse(capture[2] || capture[1], state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'em',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"em\", output(node.content, state));\n        }\n    },\n    strong: {\n        order: currOrder /* same as em */,\n        match: inlineRegex(/^\\*\\*((?:\\\\[\\s\\S]|[^\\\\])+?)\\*\\*(?!\\*)/),\n        quality: function(capture) {\n            // precedence by length, wins ties vs `u`:\n            return capture[0].length + 0.1;\n        },\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'strong',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"strong\", output(node.content, state));\n        }\n    },\n    u: {\n        order: currOrder++ /* same as em&strong; increment for next rule */,\n        match: inlineRegex(/^__((?:\\\\[\\s\\S]|[^\\\\])+?)__(?!_)/),\n        quality: function(capture) {\n            // precedence by length, loses all ties\n            return capture[0].length;\n        },\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'u',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"u\", output(node.content, state));\n        }\n    },\n    del: {\n        order: currOrder++,\n        match: inlineRegex(/^~~(?=\\S)((?:\\\\[\\s\\S]|~(?!~)|[^\\s~]|\\s(?!~~))+?)~~/),\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'del',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"del\", output(node.content, state));\n        }\n    },\n    inlineCode: {\n        order: currOrder++,\n        match: inlineRegex(/^(`+)([\\s\\S]*?[^`])\\1(?!`)/),\n        parse: function(capture, parse, state) {\n            return {\n                content: capture[2].replace(INLINE_CODE_ESCAPE_BACKTICKS_R, \"$1\")\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'code',\n                state.key,\n                {\n                    children: node.content\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"code\", sanitizeText(node.content));\n        }\n    },\n    br: {\n        order: currOrder++,\n        match: anyScopeRegex(/^ {2,}\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) {\n            return reactElement(\n                'br',\n                state.key,\n                EMPTY_PROPS\n            );\n        },\n        html: function(node, output, state) {\n            return \"<br>\";\n        }\n    },\n    text: {\n        order: currOrder++,\n        // Here we look for anything followed by non-symbols,\n        // double newlines, or double-space-newlines\n        // We break on any symbol characters so that this grammar\n        // is easy to extend without needing to modify this regex\n        match: anyScopeRegex(\n            /^[\\s\\S]+?(?=[^0-9A-Za-z\\s\\u00c0-\\uffff]|\\n\\n| {2,}\\n|\\w+:\\S|$)/\n        ),\n        parse: function(capture, parse, state) {\n            return {\n                content: capture[0]\n            };\n        },\n        react: function(node, output, state) {\n            return node.content;\n        },\n        html: function(node, output, state) {\n            return sanitizeText(node.content);\n        }\n    }\n};\n\n/** (deprecated)\n * @param {any} rules\n * @param {any} property\n * @returns {any}\n */\nvar ruleOutput = function/* :: <Rule : Object> */(\n    rules /* : OutputRules<Rule> */,\n    property /* : $Keys<Rule> */\n) {\n    if (!property && typeof console !== \"undefined\") {\n        console.warn(\"simple-markdown ruleOutput should take 'react' or \" +\n            \"'html' as the second argument.\"\n        );\n    }\n\n    /** @type {SimpleMarkdown.NodeOutput<any>} */\n    var nestedRuleOutput /* : NodeOutput<any> */ = function(\n        ast /* : SingleASTNode */,\n        outputFunc /* : Output<any> */,\n        state /* : State */\n    ) {\n        return rules[ast.type][property](ast, outputFunc, state);\n    };\n    return nestedRuleOutput;\n};\n\n/** (deprecated)\n * @param {any} outputFunc\n * @returns {any}\n */\nvar reactFor = function(outputFunc /* : ReactNodeOutput */) /* : ReactOutput */ {\n    /** @type {SimpleMarkdown.ReactOutput} */\n    var nestedOutput /* : ReactOutput */ = function(ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            var oldKey = state.key;\n            var result /* : Array<ReactElements> */ = [];\n\n            // map nestedOutput over the ast, except group any text\n            // nodes together into a single string output.\n            var lastResult = null;\n            for (var i = 0; i < ast.length; i++) {\n                state.key = '' + i;\n                var nodeOut = nestedOutput(ast[i], state);\n                if (typeof nodeOut === \"string\" && typeof lastResult === \"string\") {\n                    lastResult = lastResult + nodeOut;\n                    result[result.length - 1] = lastResult;\n                } else {\n                    result.push(nodeOut);\n                    lastResult = nodeOut;\n                }\n            }\n\n            state.key = oldKey;\n            return result;\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\n/** (deprecated)\n * @param {any} outputFunc\n * @returns {any}\n */\nvar htmlFor = function(outputFunc /* : HtmlNodeOutput */) /* : HtmlOutput */ {\n    /** @type {SimpleMarkdown.HtmlOutput} */\n    var nestedOutput /* : HtmlOutput */ = function(ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            return ast.map(function(node) {\n                return nestedOutput(node, state);\n            }).join(\"\");\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\n/**\n * @type {SimpleMarkdown.OutputFor}\n */\nvar outputFor = function/* :: <Rule : Object> */(\n    rules /* : OutputRules<Rule> */,\n    property /* : $Keys<Rule> */,\n    defaultState /* : ?State */\n) {\n    if (!property) {\n        throw new Error('simple-markdown: outputFor: `property` must be ' +\n            'defined. ' +\n            'if you just upgraded, you probably need to replace `outputFor` ' +\n            'with `reactFor`'\n        );\n    }\n\n    /** @type {SimpleMarkdown.State} */\n    var latestState;\n    /** @type {SimpleMarkdown.ArrayRule} */\n    var arrayRule = rules.Array || defaultRules.Array;\n\n    // Tricks to convince tsc that this var is not null:\n    var arrayRuleCheck = arrayRule[property];\n    if (!arrayRuleCheck) {\n        throw new Error('simple-markdown: outputFor: to join nodes of type `' +\n            property + '` you must provide an `Array:` joiner rule with that type, ' +\n            'Please see the docs for details on specifying an Array rule.'\n        );\n    }\n    var arrayRuleOutput = arrayRuleCheck;\n\n    /** @type {SimpleMarkdown.Output<any>} */\n    var nestedOutput /* : Output<any> */ = function(ast, state) {\n        state = state || latestState;\n        latestState = state;\n        if (Array.isArray(ast)) {\n            return arrayRuleOutput(ast, nestedOutput, state);\n        } else {\n            return rules[ast.type][property](ast, nestedOutput, state);\n        }\n    };\n\n    /** @type {SimpleMarkdown.Output<any>} */\n    var outerOutput = function(ast, state) {\n        latestState = populateInitialState(state, defaultState);\n        return nestedOutput(ast, latestState);\n    };\n    return outerOutput;\n};\n\nvar defaultRawParse = parserFor(defaultRules);\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {Array<SimpleMarkdown.SingleASTNode>}\n */\nvar defaultBlockParse = function(source, state) {\n    state = state || {};\n    state.inline = false;\n    return defaultRawParse(source, state);\n};\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {Array<SimpleMarkdown.SingleASTNode>}\n */\nvar defaultInlineParse = function(source, state) {\n    state = state || {};\n    state.inline = true;\n    return defaultRawParse(source, state);\n};\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {Array<SimpleMarkdown.SingleASTNode>}\n */\nvar defaultImplicitParse = function(source, state) {\n    var isBlock = BLOCK_END_R.test(source);\n    state = state || {};\n    state.inline = !isBlock;\n    return defaultRawParse(source, state);\n};\n\n/** @type {SimpleMarkdown.ReactOutput} */\nvar defaultReactOutput /* : ReactOutput */ = outputFor(defaultRules, \"react\");\n/** @type {SimpleMarkdown.HtmlOutput} */\nvar defaultHtmlOutput /* : HtmlOutput */ = outputFor(defaultRules, \"html\");\n\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {SimpleMarkdown.ReactElements}\n */\nvar markdownToReact = function(source, state) /* : ReactElements */ {\n    return defaultReactOutput(defaultBlockParse(source, state), state);\n};\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {string}\n */\nvar markdownToHtml = function(source, state) /* : string */ {\n    return defaultHtmlOutput(defaultBlockParse(source, state), state);\n};\n\n/**\n * @param {SimpleMarkdown.ReactMarkdownProps} props\n * @returns {SimpleMarkdown.ReactElement}\n */\nvar ReactMarkdown = function(props) {\n    /** @type {Object} */\n    var divProps = {};\n\n    for (var prop in props) {\n        if (prop !== 'source' &&\n            Object.prototype.hasOwnProperty.call(props, prop)\n        ) {\n            divProps[prop] = props[prop];\n        }\n    }\n    divProps.children = markdownToReact(props.source);\n\n    return reactElement(\n        'div',\n        null,\n        divProps\n    );\n};\n\n\n/*:: // Flow exports:\ntype Exports = {\n    +defaultRules: DefaultRules,\n    +parserFor: (rules: ParserRules, defaultState?: ?State) => Parser,\n    +outputFor: <Rule : Object>(rules: OutputRules<Rule>, param: $Keys<Rule>, defaultState?: ?State) => Output<any>,\n\n    +ruleOutput: <Rule : Object>(rules: OutputRules<Rule>, param: $Keys<Rule>) => NodeOutput<any>,\n    +reactFor: (ReactNodeOutput) => ReactOutput,\n    +htmlFor: (HtmlNodeOutput) => HtmlOutput,\n\n    +inlineRegex: (regex: RegExp) => MatchFunction,\n    +blockRegex: (regex: RegExp) => MatchFunction,\n    +anyScopeRegex: (regex: RegExp) => MatchFunction,\n    +parseInline: (parse: Parser, content: string, state: State) => ASTNode,\n    +parseBlock: (parse: Parser, content: string, state: State) => ASTNode,\n\n    +markdownToReact: (source: string, state?: ?State) => ReactElements,\n    +markdownToHtml: (source: string, state?: ?State) => string,\n    +ReactMarkdown: (props: { source: string, [string]: any }) => ReactElement,\n\n    +defaultRawParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultBlockParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultInlineParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultImplicitParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n\n    +defaultReactOutput: ReactOutput,\n    +defaultHtmlOutput: HtmlOutput,\n\n    +preprocess: (source: string) => string,\n    +sanitizeText: (text: Attr) => string,\n    +sanitizeUrl: (url: ?string) => ?string,\n    +unescapeUrl: (url: string) => string,\n    +htmlTag: (tagName: string, content: string, attributes: ?{ [any]: ?Attr }, isClosed: ?boolean) => string,\n    +reactElement: (type: string, key: string | null, props: { [string]: any }) => ReactElement,\n};\n\nexport type {\n    // Hopefully you shouldn't have to use these, but they're here if you need!\n    // Top-level API:\n    State,\n    Parser,\n    Output,\n    ReactOutput,\n    HtmlOutput,\n\n    // Most of the following types should be considered experimental and\n    // subject to change or change names. Again, they shouldn't be necessary,\n    // but if they are I'd love to hear how so I can better support them!\n\n    // Individual Rule fields:\n    Capture,\n    MatchFunction,\n    ParseFunction,\n    NodeOutput,\n    ArrayNodeOutput,\n    ReactNodeOutput,\n\n    // Single rules:\n    ParserRule,\n    ReactOutputRule,\n    HtmlOutputRule,\n\n    // Sets of rules:\n    ParserRules,\n    OutputRules,\n    Rules,\n    ReactRules,\n    HtmlRules,\n};\n*/\n\nvar SimpleMarkdown /* : Exports */ = {\n    defaultRules: defaultRules,\n    parserFor: parserFor,\n    outputFor: outputFor,\n\n    inlineRegex: inlineRegex,\n    blockRegex: blockRegex,\n    anyScopeRegex: anyScopeRegex,\n    parseInline: parseInline,\n    parseBlock: parseBlock,\n\n    // default wrappers:\n    markdownToReact: markdownToReact,\n    markdownToHtml: markdownToHtml,\n    ReactMarkdown: ReactMarkdown,\n\n    defaultBlockParse: defaultBlockParse,\n    defaultInlineParse: defaultInlineParse,\n    defaultImplicitParse: defaultImplicitParse,\n\n    defaultReactOutput: defaultReactOutput,\n    defaultHtmlOutput: defaultHtmlOutput,\n\n    preprocess: preprocess,\n    sanitizeText: sanitizeText,\n    sanitizeUrl: sanitizeUrl,\n    unescapeUrl: unescapeUrl,\n    htmlTag: htmlTag,\n    reactElement: reactElement,\n\n    // deprecated:\n    defaultRawParse: defaultRawParse,\n    ruleOutput: ruleOutput,\n    reactFor: reactFor,\n    htmlFor: htmlFor,\n\n    defaultParse: function() {\n        if (typeof console !== 'undefined') {\n            console.warn('defaultParse is deprecated, please use `defaultImplicitParse`');\n        }\n        return defaultImplicitParse.apply(null, /** @type {any} */ (arguments));\n    },\n    defaultOutput: function() {\n        if (typeof console !== 'undefined') {\n            console.warn('defaultOutput is deprecated, please use `defaultReactOutput`');\n        }\n        return defaultReactOutput.apply(null, /** @type {any} */ (arguments));\n    }\n};\n\nreturn SimpleMarkdown;\n\n})));\n"]},"metadata":{},"sourceType":"script"}